// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.21.12
// source: internal/bastion/proto/bastion.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	BastionService_SetupChain_FullMethodName      = "/bastion.BastionService/SetupChain"
	BastionService_ApplyRules_FullMethodName      = "/bastion.BastionService/ApplyRules"
	BastionService_CleanupChain_FullMethodName    = "/bastion.BastionService/CleanupChain"
	BastionService_Health_FullMethodName          = "/bastion.BastionService/Health"
	BastionService_AcquireNetwork_FullMethodName  = "/bastion.BastionService/AcquireNetwork"
	BastionService_ReleaseNetwork_FullMethodName  = "/bastion.BastionService/ReleaseNetwork"
	BastionService_GetNetworkStats_FullMethodName = "/bastion.BastionService/GetNetworkStats"
)

// BastionServiceClient is the client API for BastionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BastionServiceClient interface {
	SetupChain(ctx context.Context, in *SetupChainRequest, opts ...grpc.CallOption) (*SetupChainResponse, error)
	ApplyRules(ctx context.Context, in *ApplyRulesRequest, opts ...grpc.CallOption) (*ApplyRulesResponse, error)
	CleanupChain(ctx context.Context, in *CleanupChainRequest, opts ...grpc.CallOption) (*CleanupChainResponse, error)
	Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
	// Network pool management
	AcquireNetwork(ctx context.Context, in *AcquireNetworkRequest, opts ...grpc.CallOption) (*AcquireNetworkResponse, error)
	ReleaseNetwork(ctx context.Context, in *ReleaseNetworkRequest, opts ...grpc.CallOption) (*ReleaseNetworkResponse, error)
	GetNetworkStats(ctx context.Context, in *NetworkStatsRequest, opts ...grpc.CallOption) (*NetworkStatsResponse, error)
}

type bastionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBastionServiceClient(cc grpc.ClientConnInterface) BastionServiceClient {
	return &bastionServiceClient{cc}
}

func (c *bastionServiceClient) SetupChain(ctx context.Context, in *SetupChainRequest, opts ...grpc.CallOption) (*SetupChainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetupChainResponse)
	err := c.cc.Invoke(ctx, BastionService_SetupChain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bastionServiceClient) ApplyRules(ctx context.Context, in *ApplyRulesRequest, opts ...grpc.CallOption) (*ApplyRulesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApplyRulesResponse)
	err := c.cc.Invoke(ctx, BastionService_ApplyRules_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bastionServiceClient) CleanupChain(ctx context.Context, in *CleanupChainRequest, opts ...grpc.CallOption) (*CleanupChainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CleanupChainResponse)
	err := c.cc.Invoke(ctx, BastionService_CleanupChain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bastionServiceClient) Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, BastionService_Health_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bastionServiceClient) AcquireNetwork(ctx context.Context, in *AcquireNetworkRequest, opts ...grpc.CallOption) (*AcquireNetworkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AcquireNetworkResponse)
	err := c.cc.Invoke(ctx, BastionService_AcquireNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bastionServiceClient) ReleaseNetwork(ctx context.Context, in *ReleaseNetworkRequest, opts ...grpc.CallOption) (*ReleaseNetworkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReleaseNetworkResponse)
	err := c.cc.Invoke(ctx, BastionService_ReleaseNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bastionServiceClient) GetNetworkStats(ctx context.Context, in *NetworkStatsRequest, opts ...grpc.CallOption) (*NetworkStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NetworkStatsResponse)
	err := c.cc.Invoke(ctx, BastionService_GetNetworkStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BastionServiceServer is the server API for BastionService service.
// All implementations must embed UnimplementedBastionServiceServer
// for forward compatibility.
type BastionServiceServer interface {
	SetupChain(context.Context, *SetupChainRequest) (*SetupChainResponse, error)
	ApplyRules(context.Context, *ApplyRulesRequest) (*ApplyRulesResponse, error)
	CleanupChain(context.Context, *CleanupChainRequest) (*CleanupChainResponse, error)
	Health(context.Context, *HealthRequest) (*HealthResponse, error)
	// Network pool management
	AcquireNetwork(context.Context, *AcquireNetworkRequest) (*AcquireNetworkResponse, error)
	ReleaseNetwork(context.Context, *ReleaseNetworkRequest) (*ReleaseNetworkResponse, error)
	GetNetworkStats(context.Context, *NetworkStatsRequest) (*NetworkStatsResponse, error)
	mustEmbedUnimplementedBastionServiceServer()
}

// UnimplementedBastionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBastionServiceServer struct{}

func (UnimplementedBastionServiceServer) SetupChain(context.Context, *SetupChainRequest) (*SetupChainResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetupChain not implemented")
}
func (UnimplementedBastionServiceServer) ApplyRules(context.Context, *ApplyRulesRequest) (*ApplyRulesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ApplyRules not implemented")
}
func (UnimplementedBastionServiceServer) CleanupChain(context.Context, *CleanupChainRequest) (*CleanupChainResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CleanupChain not implemented")
}
func (UnimplementedBastionServiceServer) Health(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Health not implemented")
}
func (UnimplementedBastionServiceServer) AcquireNetwork(context.Context, *AcquireNetworkRequest) (*AcquireNetworkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AcquireNetwork not implemented")
}
func (UnimplementedBastionServiceServer) ReleaseNetwork(context.Context, *ReleaseNetworkRequest) (*ReleaseNetworkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReleaseNetwork not implemented")
}
func (UnimplementedBastionServiceServer) GetNetworkStats(context.Context, *NetworkStatsRequest) (*NetworkStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNetworkStats not implemented")
}
func (UnimplementedBastionServiceServer) mustEmbedUnimplementedBastionServiceServer() {}
func (UnimplementedBastionServiceServer) testEmbeddedByValue()                        {}

// UnsafeBastionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BastionServiceServer will
// result in compilation errors.
type UnsafeBastionServiceServer interface {
	mustEmbedUnimplementedBastionServiceServer()
}

func RegisterBastionServiceServer(s grpc.ServiceRegistrar, srv BastionServiceServer) {
	// If the following call panics, it indicates UnimplementedBastionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BastionService_ServiceDesc, srv)
}

func _BastionService_SetupChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetupChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BastionServiceServer).SetupChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BastionService_SetupChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BastionServiceServer).SetupChain(ctx, req.(*SetupChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BastionService_ApplyRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BastionServiceServer).ApplyRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BastionService_ApplyRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BastionServiceServer).ApplyRules(ctx, req.(*ApplyRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BastionService_CleanupChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CleanupChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BastionServiceServer).CleanupChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BastionService_CleanupChain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BastionServiceServer).CleanupChain(ctx, req.(*CleanupChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BastionService_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BastionServiceServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BastionService_Health_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BastionServiceServer).Health(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BastionService_AcquireNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcquireNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BastionServiceServer).AcquireNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BastionService_AcquireNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BastionServiceServer).AcquireNetwork(ctx, req.(*AcquireNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BastionService_ReleaseNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BastionServiceServer).ReleaseNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BastionService_ReleaseNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BastionServiceServer).ReleaseNetwork(ctx, req.(*ReleaseNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BastionService_GetNetworkStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BastionServiceServer).GetNetworkStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BastionService_GetNetworkStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BastionServiceServer).GetNetworkStats(ctx, req.(*NetworkStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BastionService_ServiceDesc is the grpc.ServiceDesc for BastionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BastionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bastion.BastionService",
	HandlerType: (*BastionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetupChain",
			Handler:    _BastionService_SetupChain_Handler,
		},
		{
			MethodName: "ApplyRules",
			Handler:    _BastionService_ApplyRules_Handler,
		},
		{
			MethodName: "CleanupChain",
			Handler:    _BastionService_CleanupChain_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _BastionService_Health_Handler,
		},
		{
			MethodName: "AcquireNetwork",
			Handler:    _BastionService_AcquireNetwork_Handler,
		},
		{
			MethodName: "ReleaseNetwork",
			Handler:    _BastionService_ReleaseNetwork_Handler,
		},
		{
			MethodName: "GetNetworkStats",
			Handler:    _BastionService_GetNetworkStats_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/bastion/proto/bastion.proto",
}
