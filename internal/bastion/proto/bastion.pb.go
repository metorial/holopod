// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: internal/bastion/proto/bastion.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SetupChainRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ChainName     string                 `protobuf:"bytes,1,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	ContainerIp   string                 `protobuf:"bytes,2,opt,name=container_ip,json=containerIp,proto3" json:"container_ip,omitempty"`
	ContainerId   string                 `protobuf:"bytes,3,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetupChainRequest) Reset() {
	*x = SetupChainRequest{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetupChainRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetupChainRequest) ProtoMessage() {}

func (x *SetupChainRequest) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetupChainRequest.ProtoReflect.Descriptor instead.
func (*SetupChainRequest) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{0}
}

func (x *SetupChainRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *SetupChainRequest) GetContainerIp() string {
	if x != nil {
		return x.ContainerIp
	}
	return ""
}

func (x *SetupChainRequest) GetContainerId() string {
	if x != nil {
		return x.ContainerId
	}
	return ""
}

type SetupChainResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         *string                `protobuf:"bytes,2,opt,name=error,proto3,oneof" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetupChainResponse) Reset() {
	*x = SetupChainResponse{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetupChainResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetupChainResponse) ProtoMessage() {}

func (x *SetupChainResponse) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetupChainResponse.ProtoReflect.Descriptor instead.
func (*SetupChainResponse) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{1}
}

func (x *SetupChainResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *SetupChainResponse) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

type ApplyRulesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ChainName     string                 `protobuf:"bytes,1,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	Policy        *NetworkPolicy         `protobuf:"bytes,2,opt,name=policy,proto3" json:"policy,omitempty"`
	ContainerId   string                 `protobuf:"bytes,3,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApplyRulesRequest) Reset() {
	*x = ApplyRulesRequest{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyRulesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyRulesRequest) ProtoMessage() {}

func (x *ApplyRulesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyRulesRequest.ProtoReflect.Descriptor instead.
func (*ApplyRulesRequest) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{2}
}

func (x *ApplyRulesRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *ApplyRulesRequest) GetPolicy() *NetworkPolicy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *ApplyRulesRequest) GetContainerId() string {
	if x != nil {
		return x.ContainerId
	}
	return ""
}

type ApplyRulesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         *string                `protobuf:"bytes,2,opt,name=error,proto3,oneof" json:"error,omitempty"`
	RulesApplied  int32                  `protobuf:"varint,3,opt,name=rules_applied,json=rulesApplied,proto3" json:"rules_applied,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ApplyRulesResponse) Reset() {
	*x = ApplyRulesResponse{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ApplyRulesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ApplyRulesResponse) ProtoMessage() {}

func (x *ApplyRulesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ApplyRulesResponse.ProtoReflect.Descriptor instead.
func (*ApplyRulesResponse) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{3}
}

func (x *ApplyRulesResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ApplyRulesResponse) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

func (x *ApplyRulesResponse) GetRulesApplied() int32 {
	if x != nil {
		return x.RulesApplied
	}
	return 0
}

type CleanupChainRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ChainName     string                 `protobuf:"bytes,1,opt,name=chain_name,json=chainName,proto3" json:"chain_name,omitempty"`
	ContainerId   string                 `protobuf:"bytes,2,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CleanupChainRequest) Reset() {
	*x = CleanupChainRequest{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CleanupChainRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleanupChainRequest) ProtoMessage() {}

func (x *CleanupChainRequest) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleanupChainRequest.ProtoReflect.Descriptor instead.
func (*CleanupChainRequest) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{4}
}

func (x *CleanupChainRequest) GetChainName() string {
	if x != nil {
		return x.ChainName
	}
	return ""
}

func (x *CleanupChainRequest) GetContainerId() string {
	if x != nil {
		return x.ContainerId
	}
	return ""
}

type CleanupChainResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         *string                `protobuf:"bytes,2,opt,name=error,proto3,oneof" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CleanupChainResponse) Reset() {
	*x = CleanupChainResponse{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CleanupChainResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CleanupChainResponse) ProtoMessage() {}

func (x *CleanupChainResponse) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CleanupChainResponse.ProtoReflect.Descriptor instead.
func (*CleanupChainResponse) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{5}
}

func (x *CleanupChainResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *CleanupChainResponse) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

type HealthRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthRequest) Reset() {
	*x = HealthRequest{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthRequest) ProtoMessage() {}

func (x *HealthRequest) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthRequest.ProtoReflect.Descriptor instead.
func (*HealthRequest) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{6}
}

type HealthResponse struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Healthy           bool                   `protobuf:"varint,1,opt,name=healthy,proto3" json:"healthy,omitempty"`
	Version           string                 `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	IptablesAvailable bool                   `protobuf:"varint,3,opt,name=iptables_available,json=iptablesAvailable,proto3" json:"iptables_available,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *HealthResponse) Reset() {
	*x = HealthResponse{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthResponse) ProtoMessage() {}

func (x *HealthResponse) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthResponse.ProtoReflect.Descriptor instead.
func (*HealthResponse) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{7}
}

func (x *HealthResponse) GetHealthy() bool {
	if x != nil {
		return x.Healthy
	}
	return false
}

func (x *HealthResponse) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *HealthResponse) GetIptablesAvailable() bool {
	if x != nil {
		return x.IptablesAvailable
	}
	return false
}

type NetworkPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Policy mode: "allow" (allowlist) or "deny" (denylist)
	Policy string `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	// Block access to metadata services (169.254.169.254)
	BlockMetadata bool `protobuf:"varint,2,opt,name=block_metadata,json=blockMetadata,proto3" json:"block_metadata,omitempty"`
	// Allow DNS queries
	AllowDns bool `protobuf:"varint,3,opt,name=allow_dns,json=allowDns,proto3" json:"allow_dns,omitempty"`
	// Custom DNS servers (validated IPs)
	DnsServers []string `protobuf:"bytes,4,rep,name=dns_servers,json=dnsServers,proto3" json:"dns_servers,omitempty"`
	// Whitelist rules (when policy = "deny")
	Whitelist []*NetworkRule `protobuf:"bytes,5,rep,name=whitelist,proto3" json:"whitelist,omitempty"`
	// Blacklist rules (when policy = "allow")
	Blacklist     []*NetworkRule `protobuf:"bytes,6,rep,name=blacklist,proto3" json:"blacklist,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkPolicy) Reset() {
	*x = NetworkPolicy{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkPolicy) ProtoMessage() {}

func (x *NetworkPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkPolicy.ProtoReflect.Descriptor instead.
func (*NetworkPolicy) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{8}
}

func (x *NetworkPolicy) GetPolicy() string {
	if x != nil {
		return x.Policy
	}
	return ""
}

func (x *NetworkPolicy) GetBlockMetadata() bool {
	if x != nil {
		return x.BlockMetadata
	}
	return false
}

func (x *NetworkPolicy) GetAllowDns() bool {
	if x != nil {
		return x.AllowDns
	}
	return false
}

func (x *NetworkPolicy) GetDnsServers() []string {
	if x != nil {
		return x.DnsServers
	}
	return nil
}

func (x *NetworkPolicy) GetWhitelist() []*NetworkRule {
	if x != nil {
		return x.Whitelist
	}
	return nil
}

func (x *NetworkPolicy) GetBlacklist() []*NetworkRule {
	if x != nil {
		return x.Blacklist
	}
	return nil
}

type NetworkRule struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Cidr          string                 `protobuf:"bytes,1,opt,name=cidr,proto3" json:"cidr,omitempty"`
	Description   *string                `protobuf:"bytes,2,opt,name=description,proto3,oneof" json:"description,omitempty"`
	Ports         []uint32               `protobuf:"varint,3,rep,packed,name=ports,proto3" json:"ports,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkRule) Reset() {
	*x = NetworkRule{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkRule) ProtoMessage() {}

func (x *NetworkRule) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkRule.ProtoReflect.Descriptor instead.
func (*NetworkRule) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{9}
}

func (x *NetworkRule) GetCidr() string {
	if x != nil {
		return x.Cidr
	}
	return ""
}

func (x *NetworkRule) GetDescription() string {
	if x != nil && x.Description != nil {
		return *x.Description
	}
	return ""
}

func (x *NetworkRule) GetPorts() []uint32 {
	if x != nil {
		return x.Ports
	}
	return nil
}

type NetworkConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Subnet requirements (e.g., "172.20.0.0/16" or empty for any)
	SubnetRange *string `protobuf:"bytes,1,opt,name=subnet_range,json=subnetRange,proto3,oneof" json:"subnet_range,omitempty"`
	// Minimum number of available IPs needed
	MinIps *uint32 `protobuf:"varint,2,opt,name=min_ips,json=minIps,proto3,oneof" json:"min_ips,omitempty"`
	// Network driver (default: "bridge")
	Driver *string `protobuf:"bytes,3,opt,name=driver,proto3,oneof" json:"driver,omitempty"`
	// Config hash for matching similar configs
	ConfigHash    string `protobuf:"bytes,4,opt,name=config_hash,json=configHash,proto3" json:"config_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkConfig) Reset() {
	*x = NetworkConfig{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkConfig) ProtoMessage() {}

func (x *NetworkConfig) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkConfig.ProtoReflect.Descriptor instead.
func (*NetworkConfig) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{10}
}

func (x *NetworkConfig) GetSubnetRange() string {
	if x != nil && x.SubnetRange != nil {
		return *x.SubnetRange
	}
	return ""
}

func (x *NetworkConfig) GetMinIps() uint32 {
	if x != nil && x.MinIps != nil {
		return *x.MinIps
	}
	return 0
}

func (x *NetworkConfig) GetDriver() string {
	if x != nil && x.Driver != nil {
		return *x.Driver
	}
	return ""
}

func (x *NetworkConfig) GetConfigHash() string {
	if x != nil {
		return x.ConfigHash
	}
	return ""
}

type AcquireNetworkRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ContainerId   string                 `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	NetworkConfig *NetworkConfig         `protobuf:"bytes,2,opt,name=network_config,json=networkConfig,proto3" json:"network_config,omitempty"`
	// How long to hold the network (seconds, default: 3600)
	LeaseDurationSecs *uint32 `protobuf:"varint,3,opt,name=lease_duration_secs,json=leaseDurationSecs,proto3,oneof" json:"lease_duration_secs,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *AcquireNetworkRequest) Reset() {
	*x = AcquireNetworkRequest{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AcquireNetworkRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AcquireNetworkRequest) ProtoMessage() {}

func (x *AcquireNetworkRequest) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AcquireNetworkRequest.ProtoReflect.Descriptor instead.
func (*AcquireNetworkRequest) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{11}
}

func (x *AcquireNetworkRequest) GetContainerId() string {
	if x != nil {
		return x.ContainerId
	}
	return ""
}

func (x *AcquireNetworkRequest) GetNetworkConfig() *NetworkConfig {
	if x != nil {
		return x.NetworkConfig
	}
	return nil
}

func (x *AcquireNetworkRequest) GetLeaseDurationSecs() uint32 {
	if x != nil && x.LeaseDurationSecs != nil {
		return *x.LeaseDurationSecs
	}
	return 0
}

type AcquireNetworkResponse struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Success bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error   *string                `protobuf:"bytes,2,opt,name=error,proto3,oneof" json:"error,omitempty"`
	// Network details if successful
	NetworkName *string `protobuf:"bytes,3,opt,name=network_name,json=networkName,proto3,oneof" json:"network_name,omitempty"`
	NetworkId   *string `protobuf:"bytes,4,opt,name=network_id,json=networkId,proto3,oneof" json:"network_id,omitempty"`
	Subnet      *string `protobuf:"bytes,5,opt,name=subnet,proto3,oneof" json:"subnet,omitempty"`
	// Whether this is a reused network (vs newly created)
	Reused        bool `protobuf:"varint,6,opt,name=reused,proto3" json:"reused,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AcquireNetworkResponse) Reset() {
	*x = AcquireNetworkResponse{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AcquireNetworkResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AcquireNetworkResponse) ProtoMessage() {}

func (x *AcquireNetworkResponse) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AcquireNetworkResponse.ProtoReflect.Descriptor instead.
func (*AcquireNetworkResponse) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{12}
}

func (x *AcquireNetworkResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *AcquireNetworkResponse) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

func (x *AcquireNetworkResponse) GetNetworkName() string {
	if x != nil && x.NetworkName != nil {
		return *x.NetworkName
	}
	return ""
}

func (x *AcquireNetworkResponse) GetNetworkId() string {
	if x != nil && x.NetworkId != nil {
		return *x.NetworkId
	}
	return ""
}

func (x *AcquireNetworkResponse) GetSubnet() string {
	if x != nil && x.Subnet != nil {
		return *x.Subnet
	}
	return ""
}

func (x *AcquireNetworkResponse) GetReused() bool {
	if x != nil {
		return x.Reused
	}
	return false
}

type ReleaseNetworkRequest struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	ContainerId string                 `protobuf:"bytes,1,opt,name=container_id,json=containerId,proto3" json:"container_id,omitempty"`
	NetworkName string                 `protobuf:"bytes,2,opt,name=network_name,json=networkName,proto3" json:"network_name,omitempty"`
	// Force immediate cleanup (default: false, uses TTL)
	ForceCleanup  *bool `protobuf:"varint,3,opt,name=force_cleanup,json=forceCleanup,proto3,oneof" json:"force_cleanup,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReleaseNetworkRequest) Reset() {
	*x = ReleaseNetworkRequest{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReleaseNetworkRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReleaseNetworkRequest) ProtoMessage() {}

func (x *ReleaseNetworkRequest) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReleaseNetworkRequest.ProtoReflect.Descriptor instead.
func (*ReleaseNetworkRequest) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{13}
}

func (x *ReleaseNetworkRequest) GetContainerId() string {
	if x != nil {
		return x.ContainerId
	}
	return ""
}

func (x *ReleaseNetworkRequest) GetNetworkName() string {
	if x != nil {
		return x.NetworkName
	}
	return ""
}

func (x *ReleaseNetworkRequest) GetForceCleanup() bool {
	if x != nil && x.ForceCleanup != nil {
		return *x.ForceCleanup
	}
	return false
}

type ReleaseNetworkResponse struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Success bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error   *string                `protobuf:"bytes,2,opt,name=error,proto3,oneof" json:"error,omitempty"`
	// Whether network was cleaned up or returned to pool
	CleanedUp     bool `protobuf:"varint,3,opt,name=cleaned_up,json=cleanedUp,proto3" json:"cleaned_up,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReleaseNetworkResponse) Reset() {
	*x = ReleaseNetworkResponse{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReleaseNetworkResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReleaseNetworkResponse) ProtoMessage() {}

func (x *ReleaseNetworkResponse) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReleaseNetworkResponse.ProtoReflect.Descriptor instead.
func (*ReleaseNetworkResponse) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{14}
}

func (x *ReleaseNetworkResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ReleaseNetworkResponse) GetError() string {
	if x != nil && x.Error != nil {
		return *x.Error
	}
	return ""
}

func (x *ReleaseNetworkResponse) GetCleanedUp() bool {
	if x != nil {
		return x.CleanedUp
	}
	return false
}

type NetworkStatsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkStatsRequest) Reset() {
	*x = NetworkStatsRequest{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkStatsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkStatsRequest) ProtoMessage() {}

func (x *NetworkStatsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkStatsRequest.ProtoReflect.Descriptor instead.
func (*NetworkStatsRequest) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{15}
}

type NetworkStatsResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	TotalNetworks  uint32                 `protobuf:"varint,1,opt,name=total_networks,json=totalNetworks,proto3" json:"total_networks,omitempty"`
	ActiveNetworks uint32                 `protobuf:"varint,2,opt,name=active_networks,json=activeNetworks,proto3" json:"active_networks,omitempty"`
	PooledNetworks uint32                 `protobuf:"varint,3,opt,name=pooled_networks,json=pooledNetworks,proto3" json:"pooled_networks,omitempty"`
	PendingCleanup uint32                 `protobuf:"varint,4,opt,name=pending_cleanup,json=pendingCleanup,proto3" json:"pending_cleanup,omitempty"`
	// Pool utilization (0.0 - 1.0)
	Utilization float32 `protobuf:"fixed32,5,opt,name=utilization,proto3" json:"utilization,omitempty"`
	// Network pool health
	Healthy bool `protobuf:"varint,6,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// Subnet utilization (0.0 - 1.0)
	SubnetUtilization float32 `protobuf:"fixed32,7,opt,name=subnet_utilization,json=subnetUtilization,proto3" json:"subnet_utilization,omitempty"`
	// Maximum available subnets
	MaxSubnets    uint32 `protobuf:"varint,8,opt,name=max_subnets,json=maxSubnets,proto3" json:"max_subnets,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkStatsResponse) Reset() {
	*x = NetworkStatsResponse{}
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkStatsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkStatsResponse) ProtoMessage() {}

func (x *NetworkStatsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_internal_bastion_proto_bastion_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkStatsResponse.ProtoReflect.Descriptor instead.
func (*NetworkStatsResponse) Descriptor() ([]byte, []int) {
	return file_internal_bastion_proto_bastion_proto_rawDescGZIP(), []int{16}
}

func (x *NetworkStatsResponse) GetTotalNetworks() uint32 {
	if x != nil {
		return x.TotalNetworks
	}
	return 0
}

func (x *NetworkStatsResponse) GetActiveNetworks() uint32 {
	if x != nil {
		return x.ActiveNetworks
	}
	return 0
}

func (x *NetworkStatsResponse) GetPooledNetworks() uint32 {
	if x != nil {
		return x.PooledNetworks
	}
	return 0
}

func (x *NetworkStatsResponse) GetPendingCleanup() uint32 {
	if x != nil {
		return x.PendingCleanup
	}
	return 0
}

func (x *NetworkStatsResponse) GetUtilization() float32 {
	if x != nil {
		return x.Utilization
	}
	return 0
}

func (x *NetworkStatsResponse) GetHealthy() bool {
	if x != nil {
		return x.Healthy
	}
	return false
}

func (x *NetworkStatsResponse) GetSubnetUtilization() float32 {
	if x != nil {
		return x.SubnetUtilization
	}
	return 0
}

func (x *NetworkStatsResponse) GetMaxSubnets() uint32 {
	if x != nil {
		return x.MaxSubnets
	}
	return 0
}

var File_internal_bastion_proto_bastion_proto protoreflect.FileDescriptor

const file_internal_bastion_proto_bastion_proto_rawDesc = "" +
	"\n" +
	"$internal/bastion/proto/bastion.proto\x12\abastion\"x\n" +
	"\x11SetupChainRequest\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x01 \x01(\tR\tchainName\x12!\n" +
	"\fcontainer_ip\x18\x02 \x01(\tR\vcontainerIp\x12!\n" +
	"\fcontainer_id\x18\x03 \x01(\tR\vcontainerId\"S\n" +
	"\x12SetupChainResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x19\n" +
	"\x05error\x18\x02 \x01(\tH\x00R\x05error\x88\x01\x01B\b\n" +
	"\x06_error\"\x85\x01\n" +
	"\x11ApplyRulesRequest\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x01 \x01(\tR\tchainName\x12.\n" +
	"\x06policy\x18\x02 \x01(\v2\x16.bastion.NetworkPolicyR\x06policy\x12!\n" +
	"\fcontainer_id\x18\x03 \x01(\tR\vcontainerId\"x\n" +
	"\x12ApplyRulesResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x19\n" +
	"\x05error\x18\x02 \x01(\tH\x00R\x05error\x88\x01\x01\x12#\n" +
	"\rrules_applied\x18\x03 \x01(\x05R\frulesAppliedB\b\n" +
	"\x06_error\"W\n" +
	"\x13CleanupChainRequest\x12\x1d\n" +
	"\n" +
	"chain_name\x18\x01 \x01(\tR\tchainName\x12!\n" +
	"\fcontainer_id\x18\x02 \x01(\tR\vcontainerId\"U\n" +
	"\x14CleanupChainResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x19\n" +
	"\x05error\x18\x02 \x01(\tH\x00R\x05error\x88\x01\x01B\b\n" +
	"\x06_error\"\x0f\n" +
	"\rHealthRequest\"s\n" +
	"\x0eHealthResponse\x12\x18\n" +
	"\ahealthy\x18\x01 \x01(\bR\ahealthy\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12-\n" +
	"\x12iptables_available\x18\x03 \x01(\bR\x11iptablesAvailable\"\xf4\x01\n" +
	"\rNetworkPolicy\x12\x16\n" +
	"\x06policy\x18\x01 \x01(\tR\x06policy\x12%\n" +
	"\x0eblock_metadata\x18\x02 \x01(\bR\rblockMetadata\x12\x1b\n" +
	"\tallow_dns\x18\x03 \x01(\bR\ballowDns\x12\x1f\n" +
	"\vdns_servers\x18\x04 \x03(\tR\n" +
	"dnsServers\x122\n" +
	"\twhitelist\x18\x05 \x03(\v2\x14.bastion.NetworkRuleR\twhitelist\x122\n" +
	"\tblacklist\x18\x06 \x03(\v2\x14.bastion.NetworkRuleR\tblacklist\"n\n" +
	"\vNetworkRule\x12\x12\n" +
	"\x04cidr\x18\x01 \x01(\tR\x04cidr\x12%\n" +
	"\vdescription\x18\x02 \x01(\tH\x00R\vdescription\x88\x01\x01\x12\x14\n" +
	"\x05ports\x18\x03 \x03(\rR\x05portsB\x0e\n" +
	"\f_description\"\xbb\x01\n" +
	"\rNetworkConfig\x12&\n" +
	"\fsubnet_range\x18\x01 \x01(\tH\x00R\vsubnetRange\x88\x01\x01\x12\x1c\n" +
	"\amin_ips\x18\x02 \x01(\rH\x01R\x06minIps\x88\x01\x01\x12\x1b\n" +
	"\x06driver\x18\x03 \x01(\tH\x02R\x06driver\x88\x01\x01\x12\x1f\n" +
	"\vconfig_hash\x18\x04 \x01(\tR\n" +
	"configHashB\x0f\n" +
	"\r_subnet_rangeB\n" +
	"\n" +
	"\b_min_ipsB\t\n" +
	"\a_driver\"\xc6\x01\n" +
	"\x15AcquireNetworkRequest\x12!\n" +
	"\fcontainer_id\x18\x01 \x01(\tR\vcontainerId\x12=\n" +
	"\x0enetwork_config\x18\x02 \x01(\v2\x16.bastion.NetworkConfigR\rnetworkConfig\x123\n" +
	"\x13lease_duration_secs\x18\x03 \x01(\rH\x00R\x11leaseDurationSecs\x88\x01\x01B\x16\n" +
	"\x14_lease_duration_secs\"\x83\x02\n" +
	"\x16AcquireNetworkResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x19\n" +
	"\x05error\x18\x02 \x01(\tH\x00R\x05error\x88\x01\x01\x12&\n" +
	"\fnetwork_name\x18\x03 \x01(\tH\x01R\vnetworkName\x88\x01\x01\x12\"\n" +
	"\n" +
	"network_id\x18\x04 \x01(\tH\x02R\tnetworkId\x88\x01\x01\x12\x1b\n" +
	"\x06subnet\x18\x05 \x01(\tH\x03R\x06subnet\x88\x01\x01\x12\x16\n" +
	"\x06reused\x18\x06 \x01(\bR\x06reusedB\b\n" +
	"\x06_errorB\x0f\n" +
	"\r_network_nameB\r\n" +
	"\v_network_idB\t\n" +
	"\a_subnet\"\x99\x01\n" +
	"\x15ReleaseNetworkRequest\x12!\n" +
	"\fcontainer_id\x18\x01 \x01(\tR\vcontainerId\x12!\n" +
	"\fnetwork_name\x18\x02 \x01(\tR\vnetworkName\x12(\n" +
	"\rforce_cleanup\x18\x03 \x01(\bH\x00R\fforceCleanup\x88\x01\x01B\x10\n" +
	"\x0e_force_cleanup\"v\n" +
	"\x16ReleaseNetworkResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x19\n" +
	"\x05error\x18\x02 \x01(\tH\x00R\x05error\x88\x01\x01\x12\x1d\n" +
	"\n" +
	"cleaned_up\x18\x03 \x01(\bR\tcleanedUpB\b\n" +
	"\x06_error\"\x15\n" +
	"\x13NetworkStatsRequest\"\xc4\x02\n" +
	"\x14NetworkStatsResponse\x12%\n" +
	"\x0etotal_networks\x18\x01 \x01(\rR\rtotalNetworks\x12'\n" +
	"\x0factive_networks\x18\x02 \x01(\rR\x0eactiveNetworks\x12'\n" +
	"\x0fpooled_networks\x18\x03 \x01(\rR\x0epooledNetworks\x12'\n" +
	"\x0fpending_cleanup\x18\x04 \x01(\rR\x0ependingCleanup\x12 \n" +
	"\vutilization\x18\x05 \x01(\x02R\vutilization\x12\x18\n" +
	"\ahealthy\x18\x06 \x01(\bR\ahealthy\x12-\n" +
	"\x12subnet_utilization\x18\a \x01(\x02R\x11subnetUtilization\x12\x1f\n" +
	"\vmax_subnets\x18\b \x01(\rR\n" +
	"maxSubnets2\x9c\x04\n" +
	"\x0eBastionService\x12E\n" +
	"\n" +
	"SetupChain\x12\x1a.bastion.SetupChainRequest\x1a\x1b.bastion.SetupChainResponse\x12E\n" +
	"\n" +
	"ApplyRules\x12\x1a.bastion.ApplyRulesRequest\x1a\x1b.bastion.ApplyRulesResponse\x12K\n" +
	"\fCleanupChain\x12\x1c.bastion.CleanupChainRequest\x1a\x1d.bastion.CleanupChainResponse\x129\n" +
	"\x06Health\x12\x16.bastion.HealthRequest\x1a\x17.bastion.HealthResponse\x12Q\n" +
	"\x0eAcquireNetwork\x12\x1e.bastion.AcquireNetworkRequest\x1a\x1f.bastion.AcquireNetworkResponse\x12Q\n" +
	"\x0eReleaseNetwork\x12\x1e.bastion.ReleaseNetworkRequest\x1a\x1f.bastion.ReleaseNetworkResponse\x12N\n" +
	"\x0fGetNetworkStats\x12\x1c.bastion.NetworkStatsRequest\x1a\x1d.bastion.NetworkStatsResponseB:Z8github.com/metorial/fleet/holopod/internal/bastion/protob\x06proto3"

var (
	file_internal_bastion_proto_bastion_proto_rawDescOnce sync.Once
	file_internal_bastion_proto_bastion_proto_rawDescData []byte
)

func file_internal_bastion_proto_bastion_proto_rawDescGZIP() []byte {
	file_internal_bastion_proto_bastion_proto_rawDescOnce.Do(func() {
		file_internal_bastion_proto_bastion_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_internal_bastion_proto_bastion_proto_rawDesc), len(file_internal_bastion_proto_bastion_proto_rawDesc)))
	})
	return file_internal_bastion_proto_bastion_proto_rawDescData
}

var file_internal_bastion_proto_bastion_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_internal_bastion_proto_bastion_proto_goTypes = []any{
	(*SetupChainRequest)(nil),      // 0: bastion.SetupChainRequest
	(*SetupChainResponse)(nil),     // 1: bastion.SetupChainResponse
	(*ApplyRulesRequest)(nil),      // 2: bastion.ApplyRulesRequest
	(*ApplyRulesResponse)(nil),     // 3: bastion.ApplyRulesResponse
	(*CleanupChainRequest)(nil),    // 4: bastion.CleanupChainRequest
	(*CleanupChainResponse)(nil),   // 5: bastion.CleanupChainResponse
	(*HealthRequest)(nil),          // 6: bastion.HealthRequest
	(*HealthResponse)(nil),         // 7: bastion.HealthResponse
	(*NetworkPolicy)(nil),          // 8: bastion.NetworkPolicy
	(*NetworkRule)(nil),            // 9: bastion.NetworkRule
	(*NetworkConfig)(nil),          // 10: bastion.NetworkConfig
	(*AcquireNetworkRequest)(nil),  // 11: bastion.AcquireNetworkRequest
	(*AcquireNetworkResponse)(nil), // 12: bastion.AcquireNetworkResponse
	(*ReleaseNetworkRequest)(nil),  // 13: bastion.ReleaseNetworkRequest
	(*ReleaseNetworkResponse)(nil), // 14: bastion.ReleaseNetworkResponse
	(*NetworkStatsRequest)(nil),    // 15: bastion.NetworkStatsRequest
	(*NetworkStatsResponse)(nil),   // 16: bastion.NetworkStatsResponse
}
var file_internal_bastion_proto_bastion_proto_depIdxs = []int32{
	8,  // 0: bastion.ApplyRulesRequest.policy:type_name -> bastion.NetworkPolicy
	9,  // 1: bastion.NetworkPolicy.whitelist:type_name -> bastion.NetworkRule
	9,  // 2: bastion.NetworkPolicy.blacklist:type_name -> bastion.NetworkRule
	10, // 3: bastion.AcquireNetworkRequest.network_config:type_name -> bastion.NetworkConfig
	0,  // 4: bastion.BastionService.SetupChain:input_type -> bastion.SetupChainRequest
	2,  // 5: bastion.BastionService.ApplyRules:input_type -> bastion.ApplyRulesRequest
	4,  // 6: bastion.BastionService.CleanupChain:input_type -> bastion.CleanupChainRequest
	6,  // 7: bastion.BastionService.Health:input_type -> bastion.HealthRequest
	11, // 8: bastion.BastionService.AcquireNetwork:input_type -> bastion.AcquireNetworkRequest
	13, // 9: bastion.BastionService.ReleaseNetwork:input_type -> bastion.ReleaseNetworkRequest
	15, // 10: bastion.BastionService.GetNetworkStats:input_type -> bastion.NetworkStatsRequest
	1,  // 11: bastion.BastionService.SetupChain:output_type -> bastion.SetupChainResponse
	3,  // 12: bastion.BastionService.ApplyRules:output_type -> bastion.ApplyRulesResponse
	5,  // 13: bastion.BastionService.CleanupChain:output_type -> bastion.CleanupChainResponse
	7,  // 14: bastion.BastionService.Health:output_type -> bastion.HealthResponse
	12, // 15: bastion.BastionService.AcquireNetwork:output_type -> bastion.AcquireNetworkResponse
	14, // 16: bastion.BastionService.ReleaseNetwork:output_type -> bastion.ReleaseNetworkResponse
	16, // 17: bastion.BastionService.GetNetworkStats:output_type -> bastion.NetworkStatsResponse
	11, // [11:18] is the sub-list for method output_type
	4,  // [4:11] is the sub-list for method input_type
	4,  // [4:4] is the sub-list for extension type_name
	4,  // [4:4] is the sub-list for extension extendee
	0,  // [0:4] is the sub-list for field type_name
}

func init() { file_internal_bastion_proto_bastion_proto_init() }
func file_internal_bastion_proto_bastion_proto_init() {
	if File_internal_bastion_proto_bastion_proto != nil {
		return
	}
	file_internal_bastion_proto_bastion_proto_msgTypes[1].OneofWrappers = []any{}
	file_internal_bastion_proto_bastion_proto_msgTypes[3].OneofWrappers = []any{}
	file_internal_bastion_proto_bastion_proto_msgTypes[5].OneofWrappers = []any{}
	file_internal_bastion_proto_bastion_proto_msgTypes[9].OneofWrappers = []any{}
	file_internal_bastion_proto_bastion_proto_msgTypes[10].OneofWrappers = []any{}
	file_internal_bastion_proto_bastion_proto_msgTypes[11].OneofWrappers = []any{}
	file_internal_bastion_proto_bastion_proto_msgTypes[12].OneofWrappers = []any{}
	file_internal_bastion_proto_bastion_proto_msgTypes[13].OneofWrappers = []any{}
	file_internal_bastion_proto_bastion_proto_msgTypes[14].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_internal_bastion_proto_bastion_proto_rawDesc), len(file_internal_bastion_proto_bastion_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_internal_bastion_proto_bastion_proto_goTypes,
		DependencyIndexes: file_internal_bastion_proto_bastion_proto_depIdxs,
		MessageInfos:      file_internal_bastion_proto_bastion_proto_msgTypes,
	}.Build()
	File_internal_bastion_proto_bastion_proto = out.File
	file_internal_bastion_proto_bastion_proto_goTypes = nil
	file_internal_bastion_proto_bastion_proto_depIdxs = nil
}
