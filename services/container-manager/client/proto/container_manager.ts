// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v3.21.12
// source: proto/container_manager.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export enum ContainerState {
  CREATED = 0,
  RUNNING = 1,
  EXITED = 2,
  FAILED = 3,
  TERMINATED = 4,
  UNRECOGNIZED = -1,
}

export function containerStateFromJSON(object: any): ContainerState {
  switch (object) {
    case 0:
    case "CREATED":
      return ContainerState.CREATED;
    case 1:
    case "RUNNING":
      return ContainerState.RUNNING;
    case 2:
    case "EXITED":
      return ContainerState.EXITED;
    case 3:
    case "FAILED":
      return ContainerState.FAILED;
    case 4:
    case "TERMINATED":
      return ContainerState.TERMINATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ContainerState.UNRECOGNIZED;
  }
}

export function containerStateToJSON(object: ContainerState): string {
  switch (object) {
    case ContainerState.CREATED:
      return "CREATED";
    case ContainerState.RUNNING:
      return "RUNNING";
    case ContainerState.EXITED:
      return "EXITED";
    case ContainerState.FAILED:
      return "FAILED";
    case ContainerState.TERMINATED:
      return "TERMINATED";
    case ContainerState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RunRequest {
  /** MUST be sent as first message - creates and starts container */
  create?:
    | CreateContainer
    | undefined;
  /** Send stdin data to container */
  stdin?:
    | Buffer
    | undefined;
  /** Close stdin stream */
  closeStdin?:
    | boolean
    | undefined;
  /** Terminate container (optional - connection close also terminates) */
  terminate?:
    | TerminateContainer
    | undefined;
  /** Heartbeat - MUST be sent at least every 30 seconds or container will be terminated */
  heartbeat?: boolean | undefined;
}

export interface CreateContainer {
  /** Unique ID for this container (if not provided, one will be generated) */
  containerId?:
    | string
    | undefined;
  /** Container configuration */
  config?: ContainerConfig | undefined;
}

export interface TerminateContainer {
  /** Force kill (SIGKILL) instead of graceful termination (SIGTERM) */
  force: boolean;
  /** Timeout for graceful termination before force kill (seconds) */
  timeoutSecs: number;
}

export interface RunResponse {
  /** Container ID for this stream */
  containerId: string;
  /** Container was created successfully */
  created?:
    | ContainerCreated
    | undefined;
  /** Stdout data from container */
  stdout?:
    | Buffer
    | undefined;
  /** Stderr data from container */
  stderr?:
    | Buffer
    | undefined;
  /** Container exited */
  exit?:
    | ContainerExit
    | undefined;
  /** Error occurred */
  error?:
    | string
    | undefined;
  /** Raw JSON message from isolation-runner (info, debug, warning, etc.) */
  message?: string | undefined;
}

export interface ContainerCreated {
  containerId: string;
  state: ContainerState;
}

export interface ContainerExit {
  exitCode: number;
  timestamp: string;
}

export interface ContainerConfig {
  /** Docker image specification with optional authentication */
  imageSpec?:
    | ImageSpec
    | undefined;
  /**
   * Command to execute in container (overrides image's default ENTRYPOINT)
   * If not specified, uses the image's default ENTRYPOINT
   */
  command: string[];
  /** Working directory */
  workdir?:
    | string
    | undefined;
  /** Environment variables */
  env: { [key: string]: string };
  /** Resource limits */
  resources?:
    | ResourceLimits
    | undefined;
  /** Network configuration */
  network?:
    | NetworkConfig
    | undefined;
  /** Timeout in seconds (0 = no timeout) */
  timeoutSecs?:
    | number
    | undefined;
  /** Whether to cleanup container after exit */
  cleanup?:
    | boolean
    | undefined;
  /**
   * Arguments to pass to the command (overrides image's default CMD)
   * If command is not specified, these are passed to the image's default ENTRYPOINT
   * If command is specified, these are appended as arguments to that command
   */
  args: string[];
}

export interface ContainerConfig_EnvEntry {
  key: string;
  value: string;
}

/** Image specification with registry and authentication */
export interface ImageSpec {
  /**
   * Registry hostname (defaults to "registry-1.docker.io" if not provided)
   * Examples: "gcr.io", "ghcr.io", "my-registry.local:5000"
   */
  registry?:
    | string
    | undefined;
  /**
   * Image name with tag or digest (without registry prefix)
   * Examples: "library/nginx:latest", "myorg/app@sha256:abc123..."
   */
  image: string;
  basicAuth?: BasicAuth | undefined;
}

/** Basic authentication for private registries */
export interface BasicAuth {
  username: string;
  password: string;
}

export interface ResourceLimits {
  /** CPU limit (e.g., "1.0" for 1 CPU) */
  cpuLimit?:
    | string
    | undefined;
  /** Memory limit (e.g., "512m", "1g") */
  memoryLimit?: string | undefined;
}

export interface NetworkConfig {
  /** Network policy rules */
  rules: NetworkRule[];
  /** Default policy (allow/deny) */
  defaultPolicy?:
    | string
    | undefined;
  /** Custom DNS servers */
  dnsServers: string[];
}

export interface NetworkRule {
  /** Rule type (allow/deny) */
  action: string;
  /** Protocol (tcp/udp/icmp) */
  protocol?:
    | string
    | undefined;
  /** Destination CIDR */
  destination?:
    | string
    | undefined;
  /** Port range start (inclusive) */
  portRangeStart?:
    | number
    | undefined;
  /** Port range end (inclusive) */
  portRangeEnd?: number | undefined;
}

export interface ListContainersRequest {
  /** Filter by state (running, exited, all) */
  filter?: string | undefined;
}

export interface ListContainersResponse {
  containers: ContainerInfo[];
}

export interface ContainerInfo {
  containerId: string;
  image: string;
  state: ContainerState;
  createdAt: string;
  finishedAt?: string | undefined;
  exitCode?: number | undefined;
  command: string[];
}

export interface GetContainerStatusRequest {
  containerId: string;
}

export interface GetContainerStatusResponse {
  success: boolean;
  error?: string | undefined;
  status?: ContainerStatus | undefined;
}

export interface ContainerStatus {
  containerId: string;
  state: ContainerState;
  createdAt: string;
  startedAt?: string | undefined;
  finishedAt?: string | undefined;
  exitCode?: number | undefined;
  pid?: number | undefined;
  config?:
    | ContainerConfig
    | undefined;
  /** I/O statistics */
  ioStats?:
    | IOStats
    | undefined;
  /** Unix timestamp when container should be cleaned up (if cleanup enabled) */
  cleanupAfter?: number | undefined;
}

export interface IOStats {
  stdinBytes: number;
  stdoutBytes: number;
  stderrBytes: number;
}

export interface HealthRequest {
}

export interface HealthResponse {
  healthy: boolean;
  version: string;
  runningContainers: number;
  totalContainers: number;
  isolationRunnerPath?: string | undefined;
  healthIssues: string[];
}

export interface GetNodeResourcesRequest {
}

export interface GetNodeResourcesResponse {
  success: boolean;
  error?: string | undefined;
  resources?: NodeResources | undefined;
}

export interface NodeResources {
  /** CPU */
  cpuCores: number;
  cpuUsagePercent: number;
  /** Memory (bytes) */
  memoryTotalBytes: number;
  memoryAvailableBytes: number;
  memoryUsedBytes: number;
  memoryUsagePercent: number;
  /** Disk (bytes) */
  diskTotalBytes: number;
  diskAvailableBytes: number;
  diskUsedBytes: number;
  diskUsagePercent: number;
  /** Container stats */
  runningContainers: number;
  totalContainers: number;
  /** Load averages */
  load1min: number;
  load5min: number;
  load15min: number;
}

export interface GetAvailableImagesRequest {
}

export interface GetAvailableImagesResponse {
  success: boolean;
  error?: string | undefined;
  images: ImageInfo[];
}

export interface ImageInfo {
  id: string;
  repoTags: string[];
  sizeBytes: number;
  created: string;
}

function createBaseRunRequest(): RunRequest {
  return { create: undefined, stdin: undefined, closeStdin: undefined, terminate: undefined, heartbeat: undefined };
}

export const RunRequest: MessageFns<RunRequest> = {
  encode(message: RunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.create !== undefined) {
      CreateContainer.encode(message.create, writer.uint32(10).fork()).join();
    }
    if (message.stdin !== undefined) {
      writer.uint32(18).bytes(message.stdin);
    }
    if (message.closeStdin !== undefined) {
      writer.uint32(24).bool(message.closeStdin);
    }
    if (message.terminate !== undefined) {
      TerminateContainer.encode(message.terminate, writer.uint32(34).fork()).join();
    }
    if (message.heartbeat !== undefined) {
      writer.uint32(40).bool(message.heartbeat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.create = CreateContainer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stdin = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.closeStdin = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.terminate = TerminateContainer.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.heartbeat = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRequest {
    return {
      create: isSet(object.create) ? CreateContainer.fromJSON(object.create) : undefined,
      stdin: isSet(object.stdin) ? Buffer.from(bytesFromBase64(object.stdin)) : undefined,
      closeStdin: isSet(object.closeStdin)
        ? globalThis.Boolean(object.closeStdin)
        : isSet(object.close_stdin)
        ? globalThis.Boolean(object.close_stdin)
        : undefined,
      terminate: isSet(object.terminate) ? TerminateContainer.fromJSON(object.terminate) : undefined,
      heartbeat: isSet(object.heartbeat) ? globalThis.Boolean(object.heartbeat) : undefined,
    };
  },

  toJSON(message: RunRequest): unknown {
    const obj: any = {};
    if (message.create !== undefined) {
      obj.create = CreateContainer.toJSON(message.create);
    }
    if (message.stdin !== undefined) {
      obj.stdin = base64FromBytes(message.stdin);
    }
    if (message.closeStdin !== undefined) {
      obj.closeStdin = message.closeStdin;
    }
    if (message.terminate !== undefined) {
      obj.terminate = TerminateContainer.toJSON(message.terminate);
    }
    if (message.heartbeat !== undefined) {
      obj.heartbeat = message.heartbeat;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunRequest>, I>>(base?: I): RunRequest {
    return RunRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunRequest>, I>>(object: I): RunRequest {
    const message = createBaseRunRequest();
    message.create = (object.create !== undefined && object.create !== null)
      ? CreateContainer.fromPartial(object.create)
      : undefined;
    message.stdin = object.stdin ?? undefined;
    message.closeStdin = object.closeStdin ?? undefined;
    message.terminate = (object.terminate !== undefined && object.terminate !== null)
      ? TerminateContainer.fromPartial(object.terminate)
      : undefined;
    message.heartbeat = object.heartbeat ?? undefined;
    return message;
  },
};

function createBaseCreateContainer(): CreateContainer {
  return { containerId: undefined, config: undefined };
}

export const CreateContainer: MessageFns<CreateContainer> = {
  encode(message: CreateContainer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerId !== undefined) {
      writer.uint32(10).string(message.containerId);
    }
    if (message.config !== undefined) {
      ContainerConfig.encode(message.config, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateContainer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.containerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.config = ContainerConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateContainer {
    return {
      containerId: isSet(object.containerId)
        ? globalThis.String(object.containerId)
        : isSet(object.container_id)
        ? globalThis.String(object.container_id)
        : undefined,
      config: isSet(object.config) ? ContainerConfig.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: CreateContainer): unknown {
    const obj: any = {};
    if (message.containerId !== undefined) {
      obj.containerId = message.containerId;
    }
    if (message.config !== undefined) {
      obj.config = ContainerConfig.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateContainer>, I>>(base?: I): CreateContainer {
    return CreateContainer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateContainer>, I>>(object: I): CreateContainer {
    const message = createBaseCreateContainer();
    message.containerId = object.containerId ?? undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? ContainerConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseTerminateContainer(): TerminateContainer {
  return { force: false, timeoutSecs: 0 };
}

export const TerminateContainer: MessageFns<TerminateContainer> = {
  encode(message: TerminateContainer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.force !== false) {
      writer.uint32(8).bool(message.force);
    }
    if (message.timeoutSecs !== 0) {
      writer.uint32(16).uint32(message.timeoutSecs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TerminateContainer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTerminateContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.force = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timeoutSecs = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TerminateContainer {
    return {
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
      timeoutSecs: isSet(object.timeoutSecs)
        ? globalThis.Number(object.timeoutSecs)
        : isSet(object.timeout_secs)
        ? globalThis.Number(object.timeout_secs)
        : 0,
    };
  },

  toJSON(message: TerminateContainer): unknown {
    const obj: any = {};
    if (message.force !== false) {
      obj.force = message.force;
    }
    if (message.timeoutSecs !== 0) {
      obj.timeoutSecs = Math.round(message.timeoutSecs);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TerminateContainer>, I>>(base?: I): TerminateContainer {
    return TerminateContainer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TerminateContainer>, I>>(object: I): TerminateContainer {
    const message = createBaseTerminateContainer();
    message.force = object.force ?? false;
    message.timeoutSecs = object.timeoutSecs ?? 0;
    return message;
  },
};

function createBaseRunResponse(): RunResponse {
  return {
    containerId: "",
    created: undefined,
    stdout: undefined,
    stderr: undefined,
    exit: undefined,
    error: undefined,
    message: undefined,
  };
}

export const RunResponse: MessageFns<RunResponse> = {
  encode(message: RunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerId !== "") {
      writer.uint32(10).string(message.containerId);
    }
    if (message.created !== undefined) {
      ContainerCreated.encode(message.created, writer.uint32(18).fork()).join();
    }
    if (message.stdout !== undefined) {
      writer.uint32(26).bytes(message.stdout);
    }
    if (message.stderr !== undefined) {
      writer.uint32(34).bytes(message.stderr);
    }
    if (message.exit !== undefined) {
      ContainerExit.encode(message.exit, writer.uint32(42).fork()).join();
    }
    if (message.error !== undefined) {
      writer.uint32(50).string(message.error);
    }
    if (message.message !== undefined) {
      writer.uint32(58).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.containerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.created = ContainerCreated.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stdout = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.stderr = Buffer.from(reader.bytes());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.exit = ContainerExit.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunResponse {
    return {
      containerId: isSet(object.containerId)
        ? globalThis.String(object.containerId)
        : isSet(object.container_id)
        ? globalThis.String(object.container_id)
        : "",
      created: isSet(object.created) ? ContainerCreated.fromJSON(object.created) : undefined,
      stdout: isSet(object.stdout) ? Buffer.from(bytesFromBase64(object.stdout)) : undefined,
      stderr: isSet(object.stderr) ? Buffer.from(bytesFromBase64(object.stderr)) : undefined,
      exit: isSet(object.exit) ? ContainerExit.fromJSON(object.exit) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: RunResponse): unknown {
    const obj: any = {};
    if (message.containerId !== "") {
      obj.containerId = message.containerId;
    }
    if (message.created !== undefined) {
      obj.created = ContainerCreated.toJSON(message.created);
    }
    if (message.stdout !== undefined) {
      obj.stdout = base64FromBytes(message.stdout);
    }
    if (message.stderr !== undefined) {
      obj.stderr = base64FromBytes(message.stderr);
    }
    if (message.exit !== undefined) {
      obj.exit = ContainerExit.toJSON(message.exit);
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunResponse>, I>>(base?: I): RunResponse {
    return RunResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunResponse>, I>>(object: I): RunResponse {
    const message = createBaseRunResponse();
    message.containerId = object.containerId ?? "";
    message.created = (object.created !== undefined && object.created !== null)
      ? ContainerCreated.fromPartial(object.created)
      : undefined;
    message.stdout = object.stdout ?? undefined;
    message.stderr = object.stderr ?? undefined;
    message.exit = (object.exit !== undefined && object.exit !== null)
      ? ContainerExit.fromPartial(object.exit)
      : undefined;
    message.error = object.error ?? undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseContainerCreated(): ContainerCreated {
  return { containerId: "", state: 0 };
}

export const ContainerCreated: MessageFns<ContainerCreated> = {
  encode(message: ContainerCreated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerId !== "") {
      writer.uint32(10).string(message.containerId);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerCreated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.containerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerCreated {
    return {
      containerId: isSet(object.containerId)
        ? globalThis.String(object.containerId)
        : isSet(object.container_id)
        ? globalThis.String(object.container_id)
        : "",
      state: isSet(object.state) ? containerStateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: ContainerCreated): unknown {
    const obj: any = {};
    if (message.containerId !== "") {
      obj.containerId = message.containerId;
    }
    if (message.state !== 0) {
      obj.state = containerStateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContainerCreated>, I>>(base?: I): ContainerCreated {
    return ContainerCreated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContainerCreated>, I>>(object: I): ContainerCreated {
    const message = createBaseContainerCreated();
    message.containerId = object.containerId ?? "";
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseContainerExit(): ContainerExit {
  return { exitCode: 0, timestamp: "" };
}

export const ContainerExit: MessageFns<ContainerExit> = {
  encode(message: ContainerExit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exitCode !== 0) {
      writer.uint32(8).int32(message.exitCode);
    }
    if (message.timestamp !== "") {
      writer.uint32(18).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerExit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerExit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerExit {
    return {
      exitCode: isSet(object.exitCode)
        ? globalThis.Number(object.exitCode)
        : isSet(object.exit_code)
        ? globalThis.Number(object.exit_code)
        : 0,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
    };
  },

  toJSON(message: ContainerExit): unknown {
    const obj: any = {};
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContainerExit>, I>>(base?: I): ContainerExit {
    return ContainerExit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContainerExit>, I>>(object: I): ContainerExit {
    const message = createBaseContainerExit();
    message.exitCode = object.exitCode ?? 0;
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseContainerConfig(): ContainerConfig {
  return {
    imageSpec: undefined,
    command: [],
    workdir: undefined,
    env: {},
    resources: undefined,
    network: undefined,
    timeoutSecs: undefined,
    cleanup: undefined,
    args: [],
  };
}

export const ContainerConfig: MessageFns<ContainerConfig> = {
  encode(message: ContainerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.imageSpec !== undefined) {
      ImageSpec.encode(message.imageSpec, writer.uint32(10).fork()).join();
    }
    for (const v of message.command) {
      writer.uint32(18).string(v!);
    }
    if (message.workdir !== undefined) {
      writer.uint32(26).string(message.workdir);
    }
    globalThis.Object.entries(message.env).forEach(([key, value]: [string, string]) => {
      ContainerConfig_EnvEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.resources !== undefined) {
      ResourceLimits.encode(message.resources, writer.uint32(42).fork()).join();
    }
    if (message.network !== undefined) {
      NetworkConfig.encode(message.network, writer.uint32(50).fork()).join();
    }
    if (message.timeoutSecs !== undefined) {
      writer.uint32(56).uint32(message.timeoutSecs);
    }
    if (message.cleanup !== undefined) {
      writer.uint32(64).bool(message.cleanup);
    }
    for (const v of message.args) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.imageSpec = ImageSpec.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.command.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workdir = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ContainerConfig_EnvEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.env[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resources = ResourceLimits.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.network = NetworkConfig.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.timeoutSecs = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.cleanup = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerConfig {
    return {
      imageSpec: isSet(object.imageSpec)
        ? ImageSpec.fromJSON(object.imageSpec)
        : isSet(object.image_spec)
        ? ImageSpec.fromJSON(object.image_spec)
        : undefined,
      command: globalThis.Array.isArray(object?.command) ? object.command.map((e: any) => globalThis.String(e)) : [],
      workdir: isSet(object.workdir) ? globalThis.String(object.workdir) : undefined,
      env: isObject(object.env)
        ? (globalThis.Object.entries(object.env) as [string, any][]).reduce(
          (acc: { [key: string]: string }, [key, value]: [string, any]) => {
            acc[key] = globalThis.String(value);
            return acc;
          },
          {},
        )
        : {},
      resources: isSet(object.resources) ? ResourceLimits.fromJSON(object.resources) : undefined,
      network: isSet(object.network) ? NetworkConfig.fromJSON(object.network) : undefined,
      timeoutSecs: isSet(object.timeoutSecs)
        ? globalThis.Number(object.timeoutSecs)
        : isSet(object.timeout_secs)
        ? globalThis.Number(object.timeout_secs)
        : undefined,
      cleanup: isSet(object.cleanup) ? globalThis.Boolean(object.cleanup) : undefined,
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ContainerConfig): unknown {
    const obj: any = {};
    if (message.imageSpec !== undefined) {
      obj.imageSpec = ImageSpec.toJSON(message.imageSpec);
    }
    if (message.command?.length) {
      obj.command = message.command;
    }
    if (message.workdir !== undefined) {
      obj.workdir = message.workdir;
    }
    if (message.env) {
      const entries = globalThis.Object.entries(message.env) as [string, string][];
      if (entries.length > 0) {
        obj.env = {};
        entries.forEach(([k, v]) => {
          obj.env[k] = v;
        });
      }
    }
    if (message.resources !== undefined) {
      obj.resources = ResourceLimits.toJSON(message.resources);
    }
    if (message.network !== undefined) {
      obj.network = NetworkConfig.toJSON(message.network);
    }
    if (message.timeoutSecs !== undefined) {
      obj.timeoutSecs = Math.round(message.timeoutSecs);
    }
    if (message.cleanup !== undefined) {
      obj.cleanup = message.cleanup;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContainerConfig>, I>>(base?: I): ContainerConfig {
    return ContainerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContainerConfig>, I>>(object: I): ContainerConfig {
    const message = createBaseContainerConfig();
    message.imageSpec = (object.imageSpec !== undefined && object.imageSpec !== null)
      ? ImageSpec.fromPartial(object.imageSpec)
      : undefined;
    message.command = object.command?.map((e) => e) || [];
    message.workdir = object.workdir ?? undefined;
    message.env = (globalThis.Object.entries(object.env ?? {}) as [string, string][]).reduce(
      (acc: { [key: string]: string }, [key, value]: [string, string]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.resources = (object.resources !== undefined && object.resources !== null)
      ? ResourceLimits.fromPartial(object.resources)
      : undefined;
    message.network = (object.network !== undefined && object.network !== null)
      ? NetworkConfig.fromPartial(object.network)
      : undefined;
    message.timeoutSecs = object.timeoutSecs ?? undefined;
    message.cleanup = object.cleanup ?? undefined;
    message.args = object.args?.map((e) => e) || [];
    return message;
  },
};

function createBaseContainerConfig_EnvEntry(): ContainerConfig_EnvEntry {
  return { key: "", value: "" };
}

export const ContainerConfig_EnvEntry: MessageFns<ContainerConfig_EnvEntry> = {
  encode(message: ContainerConfig_EnvEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerConfig_EnvEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerConfig_EnvEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerConfig_EnvEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ContainerConfig_EnvEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContainerConfig_EnvEntry>, I>>(base?: I): ContainerConfig_EnvEntry {
    return ContainerConfig_EnvEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContainerConfig_EnvEntry>, I>>(object: I): ContainerConfig_EnvEntry {
    const message = createBaseContainerConfig_EnvEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseImageSpec(): ImageSpec {
  return { registry: undefined, image: "", basicAuth: undefined };
}

export const ImageSpec: MessageFns<ImageSpec> = {
  encode(message: ImageSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registry !== undefined) {
      writer.uint32(10).string(message.registry);
    }
    if (message.image !== "") {
      writer.uint32(18).string(message.image);
    }
    if (message.basicAuth !== undefined) {
      BasicAuth.encode(message.basicAuth, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.registry = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.basicAuth = BasicAuth.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageSpec {
    return {
      registry: isSet(object.registry) ? globalThis.String(object.registry) : undefined,
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      basicAuth: isSet(object.basicAuth)
        ? BasicAuth.fromJSON(object.basicAuth)
        : isSet(object.basic_auth)
        ? BasicAuth.fromJSON(object.basic_auth)
        : undefined,
    };
  },

  toJSON(message: ImageSpec): unknown {
    const obj: any = {};
    if (message.registry !== undefined) {
      obj.registry = message.registry;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.basicAuth !== undefined) {
      obj.basicAuth = BasicAuth.toJSON(message.basicAuth);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageSpec>, I>>(base?: I): ImageSpec {
    return ImageSpec.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageSpec>, I>>(object: I): ImageSpec {
    const message = createBaseImageSpec();
    message.registry = object.registry ?? undefined;
    message.image = object.image ?? "";
    message.basicAuth = (object.basicAuth !== undefined && object.basicAuth !== null)
      ? BasicAuth.fromPartial(object.basicAuth)
      : undefined;
    return message;
  },
};

function createBaseBasicAuth(): BasicAuth {
  return { username: "", password: "" };
}

export const BasicAuth: MessageFns<BasicAuth> = {
  encode(message: BasicAuth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicAuth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicAuth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicAuth {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: BasicAuth): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BasicAuth>, I>>(base?: I): BasicAuth {
    return BasicAuth.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BasicAuth>, I>>(object: I): BasicAuth {
    const message = createBaseBasicAuth();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseResourceLimits(): ResourceLimits {
  return { cpuLimit: undefined, memoryLimit: undefined };
}

export const ResourceLimits: MessageFns<ResourceLimits> = {
  encode(message: ResourceLimits, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuLimit !== undefined) {
      writer.uint32(10).string(message.cpuLimit);
    }
    if (message.memoryLimit !== undefined) {
      writer.uint32(18).string(message.memoryLimit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceLimits {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceLimits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cpuLimit = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.memoryLimit = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceLimits {
    return {
      cpuLimit: isSet(object.cpuLimit)
        ? globalThis.String(object.cpuLimit)
        : isSet(object.cpu_limit)
        ? globalThis.String(object.cpu_limit)
        : undefined,
      memoryLimit: isSet(object.memoryLimit)
        ? globalThis.String(object.memoryLimit)
        : isSet(object.memory_limit)
        ? globalThis.String(object.memory_limit)
        : undefined,
    };
  },

  toJSON(message: ResourceLimits): unknown {
    const obj: any = {};
    if (message.cpuLimit !== undefined) {
      obj.cpuLimit = message.cpuLimit;
    }
    if (message.memoryLimit !== undefined) {
      obj.memoryLimit = message.memoryLimit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceLimits>, I>>(base?: I): ResourceLimits {
    return ResourceLimits.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceLimits>, I>>(object: I): ResourceLimits {
    const message = createBaseResourceLimits();
    message.cpuLimit = object.cpuLimit ?? undefined;
    message.memoryLimit = object.memoryLimit ?? undefined;
    return message;
  },
};

function createBaseNetworkConfig(): NetworkConfig {
  return { rules: [], defaultPolicy: undefined, dnsServers: [] };
}

export const NetworkConfig: MessageFns<NetworkConfig> = {
  encode(message: NetworkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rules) {
      NetworkRule.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.defaultPolicy !== undefined) {
      writer.uint32(18).string(message.defaultPolicy);
    }
    for (const v of message.dnsServers) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rules.push(NetworkRule.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defaultPolicy = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dnsServers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkConfig {
    return {
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => NetworkRule.fromJSON(e)) : [],
      defaultPolicy: isSet(object.defaultPolicy)
        ? globalThis.String(object.defaultPolicy)
        : isSet(object.default_policy)
        ? globalThis.String(object.default_policy)
        : undefined,
      dnsServers: globalThis.Array.isArray(object?.dnsServers)
        ? object.dnsServers.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.dns_servers)
        ? object.dns_servers.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: NetworkConfig): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => NetworkRule.toJSON(e));
    }
    if (message.defaultPolicy !== undefined) {
      obj.defaultPolicy = message.defaultPolicy;
    }
    if (message.dnsServers?.length) {
      obj.dnsServers = message.dnsServers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NetworkConfig>, I>>(base?: I): NetworkConfig {
    return NetworkConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NetworkConfig>, I>>(object: I): NetworkConfig {
    const message = createBaseNetworkConfig();
    message.rules = object.rules?.map((e) => NetworkRule.fromPartial(e)) || [];
    message.defaultPolicy = object.defaultPolicy ?? undefined;
    message.dnsServers = object.dnsServers?.map((e) => e) || [];
    return message;
  },
};

function createBaseNetworkRule(): NetworkRule {
  return {
    action: "",
    protocol: undefined,
    destination: undefined,
    portRangeStart: undefined,
    portRangeEnd: undefined,
  };
}

export const NetworkRule: MessageFns<NetworkRule> = {
  encode(message: NetworkRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.protocol !== undefined) {
      writer.uint32(18).string(message.protocol);
    }
    if (message.destination !== undefined) {
      writer.uint32(26).string(message.destination);
    }
    if (message.portRangeStart !== undefined) {
      writer.uint32(32).uint32(message.portRangeStart);
    }
    if (message.portRangeEnd !== undefined) {
      writer.uint32(40).uint32(message.portRangeEnd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.protocol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destination = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.portRangeStart = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.portRangeEnd = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkRule {
    return {
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      protocol: isSet(object.protocol) ? globalThis.String(object.protocol) : undefined,
      destination: isSet(object.destination) ? globalThis.String(object.destination) : undefined,
      portRangeStart: isSet(object.portRangeStart)
        ? globalThis.Number(object.portRangeStart)
        : isSet(object.port_range_start)
        ? globalThis.Number(object.port_range_start)
        : undefined,
      portRangeEnd: isSet(object.portRangeEnd)
        ? globalThis.Number(object.portRangeEnd)
        : isSet(object.port_range_end)
        ? globalThis.Number(object.port_range_end)
        : undefined,
    };
  },

  toJSON(message: NetworkRule): unknown {
    const obj: any = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.protocol !== undefined) {
      obj.protocol = message.protocol;
    }
    if (message.destination !== undefined) {
      obj.destination = message.destination;
    }
    if (message.portRangeStart !== undefined) {
      obj.portRangeStart = Math.round(message.portRangeStart);
    }
    if (message.portRangeEnd !== undefined) {
      obj.portRangeEnd = Math.round(message.portRangeEnd);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NetworkRule>, I>>(base?: I): NetworkRule {
    return NetworkRule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NetworkRule>, I>>(object: I): NetworkRule {
    const message = createBaseNetworkRule();
    message.action = object.action ?? "";
    message.protocol = object.protocol ?? undefined;
    message.destination = object.destination ?? undefined;
    message.portRangeStart = object.portRangeStart ?? undefined;
    message.portRangeEnd = object.portRangeEnd ?? undefined;
    return message;
  },
};

function createBaseListContainersRequest(): ListContainersRequest {
  return { filter: undefined };
}

export const ListContainersRequest: MessageFns<ListContainersRequest> = {
  encode(message: ListContainersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== undefined) {
      writer.uint32(10).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListContainersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListContainersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListContainersRequest {
    return { filter: isSet(object.filter) ? globalThis.String(object.filter) : undefined };
  },

  toJSON(message: ListContainersRequest): unknown {
    const obj: any = {};
    if (message.filter !== undefined) {
      obj.filter = message.filter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListContainersRequest>, I>>(base?: I): ListContainersRequest {
    return ListContainersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListContainersRequest>, I>>(object: I): ListContainersRequest {
    const message = createBaseListContainersRequest();
    message.filter = object.filter ?? undefined;
    return message;
  },
};

function createBaseListContainersResponse(): ListContainersResponse {
  return { containers: [] };
}

export const ListContainersResponse: MessageFns<ListContainersResponse> = {
  encode(message: ListContainersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.containers) {
      ContainerInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListContainersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListContainersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.containers.push(ContainerInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListContainersResponse {
    return {
      containers: globalThis.Array.isArray(object?.containers)
        ? object.containers.map((e: any) => ContainerInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListContainersResponse): unknown {
    const obj: any = {};
    if (message.containers?.length) {
      obj.containers = message.containers.map((e) => ContainerInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListContainersResponse>, I>>(base?: I): ListContainersResponse {
    return ListContainersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListContainersResponse>, I>>(object: I): ListContainersResponse {
    const message = createBaseListContainersResponse();
    message.containers = object.containers?.map((e) => ContainerInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseContainerInfo(): ContainerInfo {
  return {
    containerId: "",
    image: "",
    state: 0,
    createdAt: "",
    finishedAt: undefined,
    exitCode: undefined,
    command: [],
  };
}

export const ContainerInfo: MessageFns<ContainerInfo> = {
  encode(message: ContainerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerId !== "") {
      writer.uint32(10).string(message.containerId);
    }
    if (message.image !== "") {
      writer.uint32(18).string(message.image);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.createdAt !== "") {
      writer.uint32(34).string(message.createdAt);
    }
    if (message.finishedAt !== undefined) {
      writer.uint32(42).string(message.finishedAt);
    }
    if (message.exitCode !== undefined) {
      writer.uint32(48).int32(message.exitCode);
    }
    for (const v of message.command) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.containerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.finishedAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.command.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerInfo {
    return {
      containerId: isSet(object.containerId)
        ? globalThis.String(object.containerId)
        : isSet(object.container_id)
        ? globalThis.String(object.container_id)
        : "",
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      state: isSet(object.state) ? containerStateFromJSON(object.state) : 0,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      finishedAt: isSet(object.finishedAt)
        ? globalThis.String(object.finishedAt)
        : isSet(object.finished_at)
        ? globalThis.String(object.finished_at)
        : undefined,
      exitCode: isSet(object.exitCode)
        ? globalThis.Number(object.exitCode)
        : isSet(object.exit_code)
        ? globalThis.Number(object.exit_code)
        : undefined,
      command: globalThis.Array.isArray(object?.command)
        ? object.command.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ContainerInfo): unknown {
    const obj: any = {};
    if (message.containerId !== "") {
      obj.containerId = message.containerId;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.state !== 0) {
      obj.state = containerStateToJSON(message.state);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.finishedAt !== undefined) {
      obj.finishedAt = message.finishedAt;
    }
    if (message.exitCode !== undefined) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.command?.length) {
      obj.command = message.command;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContainerInfo>, I>>(base?: I): ContainerInfo {
    return ContainerInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContainerInfo>, I>>(object: I): ContainerInfo {
    const message = createBaseContainerInfo();
    message.containerId = object.containerId ?? "";
    message.image = object.image ?? "";
    message.state = object.state ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.finishedAt = object.finishedAt ?? undefined;
    message.exitCode = object.exitCode ?? undefined;
    message.command = object.command?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetContainerStatusRequest(): GetContainerStatusRequest {
  return { containerId: "" };
}

export const GetContainerStatusRequest: MessageFns<GetContainerStatusRequest> = {
  encode(message: GetContainerStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerId !== "") {
      writer.uint32(10).string(message.containerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContainerStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContainerStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.containerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContainerStatusRequest {
    return {
      containerId: isSet(object.containerId)
        ? globalThis.String(object.containerId)
        : isSet(object.container_id)
        ? globalThis.String(object.container_id)
        : "",
    };
  },

  toJSON(message: GetContainerStatusRequest): unknown {
    const obj: any = {};
    if (message.containerId !== "") {
      obj.containerId = message.containerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContainerStatusRequest>, I>>(base?: I): GetContainerStatusRequest {
    return GetContainerStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContainerStatusRequest>, I>>(object: I): GetContainerStatusRequest {
    const message = createBaseGetContainerStatusRequest();
    message.containerId = object.containerId ?? "";
    return message;
  },
};

function createBaseGetContainerStatusResponse(): GetContainerStatusResponse {
  return { success: false, error: undefined, status: undefined };
}

export const GetContainerStatusResponse: MessageFns<GetContainerStatusResponse> = {
  encode(message: GetContainerStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== undefined) {
      writer.uint32(18).string(message.error);
    }
    if (message.status !== undefined) {
      ContainerStatus.encode(message.status, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetContainerStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetContainerStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = ContainerStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetContainerStatusResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
      status: isSet(object.status) ? ContainerStatus.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: GetContainerStatusResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    if (message.status !== undefined) {
      obj.status = ContainerStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetContainerStatusResponse>, I>>(base?: I): GetContainerStatusResponse {
    return GetContainerStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetContainerStatusResponse>, I>>(object: I): GetContainerStatusResponse {
    const message = createBaseGetContainerStatusResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? undefined;
    message.status = (object.status !== undefined && object.status !== null)
      ? ContainerStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseContainerStatus(): ContainerStatus {
  return {
    containerId: "",
    state: 0,
    createdAt: "",
    startedAt: undefined,
    finishedAt: undefined,
    exitCode: undefined,
    pid: undefined,
    config: undefined,
    ioStats: undefined,
    cleanupAfter: undefined,
  };
}

export const ContainerStatus: MessageFns<ContainerStatus> = {
  encode(message: ContainerStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerId !== "") {
      writer.uint32(10).string(message.containerId);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.createdAt !== "") {
      writer.uint32(26).string(message.createdAt);
    }
    if (message.startedAt !== undefined) {
      writer.uint32(34).string(message.startedAt);
    }
    if (message.finishedAt !== undefined) {
      writer.uint32(42).string(message.finishedAt);
    }
    if (message.exitCode !== undefined) {
      writer.uint32(48).int32(message.exitCode);
    }
    if (message.pid !== undefined) {
      writer.uint32(56).int32(message.pid);
    }
    if (message.config !== undefined) {
      ContainerConfig.encode(message.config, writer.uint32(66).fork()).join();
    }
    if (message.ioStats !== undefined) {
      IOStats.encode(message.ioStats, writer.uint32(74).fork()).join();
    }
    if (message.cleanupAfter !== undefined) {
      writer.uint32(80).int64(message.cleanupAfter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.containerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startedAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.finishedAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.pid = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.config = ContainerConfig.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ioStats = IOStats.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.cleanupAfter = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerStatus {
    return {
      containerId: isSet(object.containerId)
        ? globalThis.String(object.containerId)
        : isSet(object.container_id)
        ? globalThis.String(object.container_id)
        : "",
      state: isSet(object.state) ? containerStateFromJSON(object.state) : 0,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      startedAt: isSet(object.startedAt)
        ? globalThis.String(object.startedAt)
        : isSet(object.started_at)
        ? globalThis.String(object.started_at)
        : undefined,
      finishedAt: isSet(object.finishedAt)
        ? globalThis.String(object.finishedAt)
        : isSet(object.finished_at)
        ? globalThis.String(object.finished_at)
        : undefined,
      exitCode: isSet(object.exitCode)
        ? globalThis.Number(object.exitCode)
        : isSet(object.exit_code)
        ? globalThis.Number(object.exit_code)
        : undefined,
      pid: isSet(object.pid) ? globalThis.Number(object.pid) : undefined,
      config: isSet(object.config) ? ContainerConfig.fromJSON(object.config) : undefined,
      ioStats: isSet(object.ioStats)
        ? IOStats.fromJSON(object.ioStats)
        : isSet(object.io_stats)
        ? IOStats.fromJSON(object.io_stats)
        : undefined,
      cleanupAfter: isSet(object.cleanupAfter)
        ? globalThis.Number(object.cleanupAfter)
        : isSet(object.cleanup_after)
        ? globalThis.Number(object.cleanup_after)
        : undefined,
    };
  },

  toJSON(message: ContainerStatus): unknown {
    const obj: any = {};
    if (message.containerId !== "") {
      obj.containerId = message.containerId;
    }
    if (message.state !== 0) {
      obj.state = containerStateToJSON(message.state);
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.startedAt !== undefined) {
      obj.startedAt = message.startedAt;
    }
    if (message.finishedAt !== undefined) {
      obj.finishedAt = message.finishedAt;
    }
    if (message.exitCode !== undefined) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.pid !== undefined) {
      obj.pid = Math.round(message.pid);
    }
    if (message.config !== undefined) {
      obj.config = ContainerConfig.toJSON(message.config);
    }
    if (message.ioStats !== undefined) {
      obj.ioStats = IOStats.toJSON(message.ioStats);
    }
    if (message.cleanupAfter !== undefined) {
      obj.cleanupAfter = Math.round(message.cleanupAfter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ContainerStatus>, I>>(base?: I): ContainerStatus {
    return ContainerStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ContainerStatus>, I>>(object: I): ContainerStatus {
    const message = createBaseContainerStatus();
    message.containerId = object.containerId ?? "";
    message.state = object.state ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.startedAt = object.startedAt ?? undefined;
    message.finishedAt = object.finishedAt ?? undefined;
    message.exitCode = object.exitCode ?? undefined;
    message.pid = object.pid ?? undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? ContainerConfig.fromPartial(object.config)
      : undefined;
    message.ioStats = (object.ioStats !== undefined && object.ioStats !== null)
      ? IOStats.fromPartial(object.ioStats)
      : undefined;
    message.cleanupAfter = object.cleanupAfter ?? undefined;
    return message;
  },
};

function createBaseIOStats(): IOStats {
  return { stdinBytes: 0, stdoutBytes: 0, stderrBytes: 0 };
}

export const IOStats: MessageFns<IOStats> = {
  encode(message: IOStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stdinBytes !== 0) {
      writer.uint32(8).uint64(message.stdinBytes);
    }
    if (message.stdoutBytes !== 0) {
      writer.uint32(16).uint64(message.stdoutBytes);
    }
    if (message.stderrBytes !== 0) {
      writer.uint32(24).uint64(message.stderrBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IOStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIOStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.stdinBytes = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stdoutBytes = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.stderrBytes = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IOStats {
    return {
      stdinBytes: isSet(object.stdinBytes)
        ? globalThis.Number(object.stdinBytes)
        : isSet(object.stdin_bytes)
        ? globalThis.Number(object.stdin_bytes)
        : 0,
      stdoutBytes: isSet(object.stdoutBytes)
        ? globalThis.Number(object.stdoutBytes)
        : isSet(object.stdout_bytes)
        ? globalThis.Number(object.stdout_bytes)
        : 0,
      stderrBytes: isSet(object.stderrBytes)
        ? globalThis.Number(object.stderrBytes)
        : isSet(object.stderr_bytes)
        ? globalThis.Number(object.stderr_bytes)
        : 0,
    };
  },

  toJSON(message: IOStats): unknown {
    const obj: any = {};
    if (message.stdinBytes !== 0) {
      obj.stdinBytes = Math.round(message.stdinBytes);
    }
    if (message.stdoutBytes !== 0) {
      obj.stdoutBytes = Math.round(message.stdoutBytes);
    }
    if (message.stderrBytes !== 0) {
      obj.stderrBytes = Math.round(message.stderrBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IOStats>, I>>(base?: I): IOStats {
    return IOStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IOStats>, I>>(object: I): IOStats {
    const message = createBaseIOStats();
    message.stdinBytes = object.stdinBytes ?? 0;
    message.stdoutBytes = object.stdoutBytes ?? 0;
    message.stderrBytes = object.stderrBytes ?? 0;
    return message;
  },
};

function createBaseHealthRequest(): HealthRequest {
  return {};
}

export const HealthRequest: MessageFns<HealthRequest> = {
  encode(_: HealthRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthRequest {
    return {};
  },

  toJSON(_: HealthRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthRequest>, I>>(base?: I): HealthRequest {
    return HealthRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthRequest>, I>>(_: I): HealthRequest {
    const message = createBaseHealthRequest();
    return message;
  },
};

function createBaseHealthResponse(): HealthResponse {
  return {
    healthy: false,
    version: "",
    runningContainers: 0,
    totalContainers: 0,
    isolationRunnerPath: undefined,
    healthIssues: [],
  };
}

export const HealthResponse: MessageFns<HealthResponse> = {
  encode(message: HealthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.healthy !== false) {
      writer.uint32(8).bool(message.healthy);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.runningContainers !== 0) {
      writer.uint32(24).uint32(message.runningContainers);
    }
    if (message.totalContainers !== 0) {
      writer.uint32(32).uint32(message.totalContainers);
    }
    if (message.isolationRunnerPath !== undefined) {
      writer.uint32(42).string(message.isolationRunnerPath);
    }
    for (const v of message.healthIssues) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.healthy = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.runningContainers = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalContainers = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.isolationRunnerPath = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.healthIssues.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthResponse {
    return {
      healthy: isSet(object.healthy) ? globalThis.Boolean(object.healthy) : false,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      runningContainers: isSet(object.runningContainers)
        ? globalThis.Number(object.runningContainers)
        : isSet(object.running_containers)
        ? globalThis.Number(object.running_containers)
        : 0,
      totalContainers: isSet(object.totalContainers)
        ? globalThis.Number(object.totalContainers)
        : isSet(object.total_containers)
        ? globalThis.Number(object.total_containers)
        : 0,
      isolationRunnerPath: isSet(object.isolationRunnerPath)
        ? globalThis.String(object.isolationRunnerPath)
        : isSet(object.isolation_runner_path)
        ? globalThis.String(object.isolation_runner_path)
        : undefined,
      healthIssues: globalThis.Array.isArray(object?.healthIssues)
        ? object.healthIssues.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.health_issues)
        ? object.health_issues.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: HealthResponse): unknown {
    const obj: any = {};
    if (message.healthy !== false) {
      obj.healthy = message.healthy;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.runningContainers !== 0) {
      obj.runningContainers = Math.round(message.runningContainers);
    }
    if (message.totalContainers !== 0) {
      obj.totalContainers = Math.round(message.totalContainers);
    }
    if (message.isolationRunnerPath !== undefined) {
      obj.isolationRunnerPath = message.isolationRunnerPath;
    }
    if (message.healthIssues?.length) {
      obj.healthIssues = message.healthIssues;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthResponse>, I>>(base?: I): HealthResponse {
    return HealthResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthResponse>, I>>(object: I): HealthResponse {
    const message = createBaseHealthResponse();
    message.healthy = object.healthy ?? false;
    message.version = object.version ?? "";
    message.runningContainers = object.runningContainers ?? 0;
    message.totalContainers = object.totalContainers ?? 0;
    message.isolationRunnerPath = object.isolationRunnerPath ?? undefined;
    message.healthIssues = object.healthIssues?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetNodeResourcesRequest(): GetNodeResourcesRequest {
  return {};
}

export const GetNodeResourcesRequest: MessageFns<GetNodeResourcesRequest> = {
  encode(_: GetNodeResourcesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeResourcesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetNodeResourcesRequest {
    return {};
  },

  toJSON(_: GetNodeResourcesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeResourcesRequest>, I>>(base?: I): GetNodeResourcesRequest {
    return GetNodeResourcesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeResourcesRequest>, I>>(_: I): GetNodeResourcesRequest {
    const message = createBaseGetNodeResourcesRequest();
    return message;
  },
};

function createBaseGetNodeResourcesResponse(): GetNodeResourcesResponse {
  return { success: false, error: undefined, resources: undefined };
}

export const GetNodeResourcesResponse: MessageFns<GetNodeResourcesResponse> = {
  encode(message: GetNodeResourcesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== undefined) {
      writer.uint32(18).string(message.error);
    }
    if (message.resources !== undefined) {
      NodeResources.encode(message.resources, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeResourcesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resources = NodeResources.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeResourcesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
      resources: isSet(object.resources) ? NodeResources.fromJSON(object.resources) : undefined,
    };
  },

  toJSON(message: GetNodeResourcesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    if (message.resources !== undefined) {
      obj.resources = NodeResources.toJSON(message.resources);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNodeResourcesResponse>, I>>(base?: I): GetNodeResourcesResponse {
    return GetNodeResourcesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNodeResourcesResponse>, I>>(object: I): GetNodeResourcesResponse {
    const message = createBaseGetNodeResourcesResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? undefined;
    message.resources = (object.resources !== undefined && object.resources !== null)
      ? NodeResources.fromPartial(object.resources)
      : undefined;
    return message;
  },
};

function createBaseNodeResources(): NodeResources {
  return {
    cpuCores: 0,
    cpuUsagePercent: 0,
    memoryTotalBytes: 0,
    memoryAvailableBytes: 0,
    memoryUsedBytes: 0,
    memoryUsagePercent: 0,
    diskTotalBytes: 0,
    diskAvailableBytes: 0,
    diskUsedBytes: 0,
    diskUsagePercent: 0,
    runningContainers: 0,
    totalContainers: 0,
    load1min: 0,
    load5min: 0,
    load15min: 0,
  };
}

export const NodeResources: MessageFns<NodeResources> = {
  encode(message: NodeResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuCores !== 0) {
      writer.uint32(8).uint32(message.cpuCores);
    }
    if (message.cpuUsagePercent !== 0) {
      writer.uint32(21).float(message.cpuUsagePercent);
    }
    if (message.memoryTotalBytes !== 0) {
      writer.uint32(24).uint64(message.memoryTotalBytes);
    }
    if (message.memoryAvailableBytes !== 0) {
      writer.uint32(32).uint64(message.memoryAvailableBytes);
    }
    if (message.memoryUsedBytes !== 0) {
      writer.uint32(40).uint64(message.memoryUsedBytes);
    }
    if (message.memoryUsagePercent !== 0) {
      writer.uint32(53).float(message.memoryUsagePercent);
    }
    if (message.diskTotalBytes !== 0) {
      writer.uint32(56).uint64(message.diskTotalBytes);
    }
    if (message.diskAvailableBytes !== 0) {
      writer.uint32(64).uint64(message.diskAvailableBytes);
    }
    if (message.diskUsedBytes !== 0) {
      writer.uint32(72).uint64(message.diskUsedBytes);
    }
    if (message.diskUsagePercent !== 0) {
      writer.uint32(85).float(message.diskUsagePercent);
    }
    if (message.runningContainers !== 0) {
      writer.uint32(88).uint32(message.runningContainers);
    }
    if (message.totalContainers !== 0) {
      writer.uint32(96).uint32(message.totalContainers);
    }
    if (message.load1min !== 0) {
      writer.uint32(109).float(message.load1min);
    }
    if (message.load5min !== 0) {
      writer.uint32(117).float(message.load5min);
    }
    if (message.load15min !== 0) {
      writer.uint32(125).float(message.load15min);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cpuCores = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.cpuUsagePercent = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.memoryTotalBytes = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.memoryAvailableBytes = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.memoryUsedBytes = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.memoryUsagePercent = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.diskTotalBytes = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.diskAvailableBytes = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.diskUsedBytes = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.diskUsagePercent = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.runningContainers = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.totalContainers = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 109) {
            break;
          }

          message.load1min = reader.float();
          continue;
        }
        case 14: {
          if (tag !== 117) {
            break;
          }

          message.load5min = reader.float();
          continue;
        }
        case 15: {
          if (tag !== 125) {
            break;
          }

          message.load15min = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeResources {
    return {
      cpuCores: isSet(object.cpuCores)
        ? globalThis.Number(object.cpuCores)
        : isSet(object.cpu_cores)
        ? globalThis.Number(object.cpu_cores)
        : 0,
      cpuUsagePercent: isSet(object.cpuUsagePercent)
        ? globalThis.Number(object.cpuUsagePercent)
        : isSet(object.cpu_usage_percent)
        ? globalThis.Number(object.cpu_usage_percent)
        : 0,
      memoryTotalBytes: isSet(object.memoryTotalBytes)
        ? globalThis.Number(object.memoryTotalBytes)
        : isSet(object.memory_total_bytes)
        ? globalThis.Number(object.memory_total_bytes)
        : 0,
      memoryAvailableBytes: isSet(object.memoryAvailableBytes)
        ? globalThis.Number(object.memoryAvailableBytes)
        : isSet(object.memory_available_bytes)
        ? globalThis.Number(object.memory_available_bytes)
        : 0,
      memoryUsedBytes: isSet(object.memoryUsedBytes)
        ? globalThis.Number(object.memoryUsedBytes)
        : isSet(object.memory_used_bytes)
        ? globalThis.Number(object.memory_used_bytes)
        : 0,
      memoryUsagePercent: isSet(object.memoryUsagePercent)
        ? globalThis.Number(object.memoryUsagePercent)
        : isSet(object.memory_usage_percent)
        ? globalThis.Number(object.memory_usage_percent)
        : 0,
      diskTotalBytes: isSet(object.diskTotalBytes)
        ? globalThis.Number(object.diskTotalBytes)
        : isSet(object.disk_total_bytes)
        ? globalThis.Number(object.disk_total_bytes)
        : 0,
      diskAvailableBytes: isSet(object.diskAvailableBytes)
        ? globalThis.Number(object.diskAvailableBytes)
        : isSet(object.disk_available_bytes)
        ? globalThis.Number(object.disk_available_bytes)
        : 0,
      diskUsedBytes: isSet(object.diskUsedBytes)
        ? globalThis.Number(object.diskUsedBytes)
        : isSet(object.disk_used_bytes)
        ? globalThis.Number(object.disk_used_bytes)
        : 0,
      diskUsagePercent: isSet(object.diskUsagePercent)
        ? globalThis.Number(object.diskUsagePercent)
        : isSet(object.disk_usage_percent)
        ? globalThis.Number(object.disk_usage_percent)
        : 0,
      runningContainers: isSet(object.runningContainers)
        ? globalThis.Number(object.runningContainers)
        : isSet(object.running_containers)
        ? globalThis.Number(object.running_containers)
        : 0,
      totalContainers: isSet(object.totalContainers)
        ? globalThis.Number(object.totalContainers)
        : isSet(object.total_containers)
        ? globalThis.Number(object.total_containers)
        : 0,
      load1min: isSet(object.load1min)
        ? globalThis.Number(object.load1min)
        : isSet(object.load_1min)
        ? globalThis.Number(object.load_1min)
        : 0,
      load5min: isSet(object.load5min)
        ? globalThis.Number(object.load5min)
        : isSet(object.load_5min)
        ? globalThis.Number(object.load_5min)
        : 0,
      load15min: isSet(object.load15min)
        ? globalThis.Number(object.load15min)
        : isSet(object.load_15min)
        ? globalThis.Number(object.load_15min)
        : 0,
    };
  },

  toJSON(message: NodeResources): unknown {
    const obj: any = {};
    if (message.cpuCores !== 0) {
      obj.cpuCores = Math.round(message.cpuCores);
    }
    if (message.cpuUsagePercent !== 0) {
      obj.cpuUsagePercent = message.cpuUsagePercent;
    }
    if (message.memoryTotalBytes !== 0) {
      obj.memoryTotalBytes = Math.round(message.memoryTotalBytes);
    }
    if (message.memoryAvailableBytes !== 0) {
      obj.memoryAvailableBytes = Math.round(message.memoryAvailableBytes);
    }
    if (message.memoryUsedBytes !== 0) {
      obj.memoryUsedBytes = Math.round(message.memoryUsedBytes);
    }
    if (message.memoryUsagePercent !== 0) {
      obj.memoryUsagePercent = message.memoryUsagePercent;
    }
    if (message.diskTotalBytes !== 0) {
      obj.diskTotalBytes = Math.round(message.diskTotalBytes);
    }
    if (message.diskAvailableBytes !== 0) {
      obj.diskAvailableBytes = Math.round(message.diskAvailableBytes);
    }
    if (message.diskUsedBytes !== 0) {
      obj.diskUsedBytes = Math.round(message.diskUsedBytes);
    }
    if (message.diskUsagePercent !== 0) {
      obj.diskUsagePercent = message.diskUsagePercent;
    }
    if (message.runningContainers !== 0) {
      obj.runningContainers = Math.round(message.runningContainers);
    }
    if (message.totalContainers !== 0) {
      obj.totalContainers = Math.round(message.totalContainers);
    }
    if (message.load1min !== 0) {
      obj.load1min = message.load1min;
    }
    if (message.load5min !== 0) {
      obj.load5min = message.load5min;
    }
    if (message.load15min !== 0) {
      obj.load15min = message.load15min;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NodeResources>, I>>(base?: I): NodeResources {
    return NodeResources.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NodeResources>, I>>(object: I): NodeResources {
    const message = createBaseNodeResources();
    message.cpuCores = object.cpuCores ?? 0;
    message.cpuUsagePercent = object.cpuUsagePercent ?? 0;
    message.memoryTotalBytes = object.memoryTotalBytes ?? 0;
    message.memoryAvailableBytes = object.memoryAvailableBytes ?? 0;
    message.memoryUsedBytes = object.memoryUsedBytes ?? 0;
    message.memoryUsagePercent = object.memoryUsagePercent ?? 0;
    message.diskTotalBytes = object.diskTotalBytes ?? 0;
    message.diskAvailableBytes = object.diskAvailableBytes ?? 0;
    message.diskUsedBytes = object.diskUsedBytes ?? 0;
    message.diskUsagePercent = object.diskUsagePercent ?? 0;
    message.runningContainers = object.runningContainers ?? 0;
    message.totalContainers = object.totalContainers ?? 0;
    message.load1min = object.load1min ?? 0;
    message.load5min = object.load5min ?? 0;
    message.load15min = object.load15min ?? 0;
    return message;
  },
};

function createBaseGetAvailableImagesRequest(): GetAvailableImagesRequest {
  return {};
}

export const GetAvailableImagesRequest: MessageFns<GetAvailableImagesRequest> = {
  encode(_: GetAvailableImagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableImagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableImagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetAvailableImagesRequest {
    return {};
  },

  toJSON(_: GetAvailableImagesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAvailableImagesRequest>, I>>(base?: I): GetAvailableImagesRequest {
    return GetAvailableImagesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAvailableImagesRequest>, I>>(_: I): GetAvailableImagesRequest {
    const message = createBaseGetAvailableImagesRequest();
    return message;
  },
};

function createBaseGetAvailableImagesResponse(): GetAvailableImagesResponse {
  return { success: false, error: undefined, images: [] };
}

export const GetAvailableImagesResponse: MessageFns<GetAvailableImagesResponse> = {
  encode(message: GetAvailableImagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== undefined) {
      writer.uint32(18).string(message.error);
    }
    for (const v of message.images) {
      ImageInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAvailableImagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAvailableImagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.images.push(ImageInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAvailableImagesResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
      images: globalThis.Array.isArray(object?.images) ? object.images.map((e: any) => ImageInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetAvailableImagesResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    if (message.images?.length) {
      obj.images = message.images.map((e) => ImageInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetAvailableImagesResponse>, I>>(base?: I): GetAvailableImagesResponse {
    return GetAvailableImagesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetAvailableImagesResponse>, I>>(object: I): GetAvailableImagesResponse {
    const message = createBaseGetAvailableImagesResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? undefined;
    message.images = object.images?.map((e) => ImageInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseImageInfo(): ImageInfo {
  return { id: "", repoTags: [], sizeBytes: 0, created: "" };
}

export const ImageInfo: MessageFns<ImageInfo> = {
  encode(message: ImageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.repoTags) {
      writer.uint32(18).string(v!);
    }
    if (message.sizeBytes !== 0) {
      writer.uint32(24).uint64(message.sizeBytes);
    }
    if (message.created !== "") {
      writer.uint32(34).string(message.created);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.repoTags.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sizeBytes = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.created = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImageInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      repoTags: globalThis.Array.isArray(object?.repoTags)
        ? object.repoTags.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.repo_tags)
        ? object.repo_tags.map((e: any) => globalThis.String(e))
        : [],
      sizeBytes: isSet(object.sizeBytes)
        ? globalThis.Number(object.sizeBytes)
        : isSet(object.size_bytes)
        ? globalThis.Number(object.size_bytes)
        : 0,
      created: isSet(object.created) ? globalThis.String(object.created) : "",
    };
  },

  toJSON(message: ImageInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.repoTags?.length) {
      obj.repoTags = message.repoTags;
    }
    if (message.sizeBytes !== 0) {
      obj.sizeBytes = Math.round(message.sizeBytes);
    }
    if (message.created !== "") {
      obj.created = message.created;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ImageInfo>, I>>(base?: I): ImageInfo {
    return ImageInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ImageInfo>, I>>(object: I): ImageInfo {
    const message = createBaseImageInfo();
    message.id = object.id ?? "";
    message.repoTags = object.repoTags?.map((e) => e) || [];
    message.sizeBytes = object.sizeBytes ?? 0;
    message.created = object.created ?? "";
    return message;
  },
};

/**
 * Container Manager Service
 * Manages isolation-runner subprocesses for container lifecycle
 */
export type ContainerManagerService = typeof ContainerManagerService;
export const ContainerManagerService = {
  /**
   * Unified bidirectional stream for container lifecycle
   * First message MUST be RunRequest with create field set
   * Server sends stdout/stderr/messages/exit events
   * Client can send stdin
   * Client MUST send heartbeat every 30 seconds or container will be terminated
   * Connection close/interrupt automatically terminates container
   */
  run: {
    path: "/container_manager.ContainerManager/Run",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: RunRequest): Buffer => Buffer.from(RunRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RunRequest => RunRequest.decode(value),
    responseSerialize: (value: RunResponse): Buffer => Buffer.from(RunResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RunResponse => RunResponse.decode(value),
  },
  /** List all containers (running and recent) */
  listContainers: {
    path: "/container_manager.ContainerManager/ListContainers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListContainersRequest): Buffer =>
      Buffer.from(ListContainersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListContainersRequest => ListContainersRequest.decode(value),
    responseSerialize: (value: ListContainersResponse): Buffer =>
      Buffer.from(ListContainersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListContainersResponse => ListContainersResponse.decode(value),
  },
  /** Get status of a specific container */
  getContainerStatus: {
    path: "/container_manager.ContainerManager/GetContainerStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetContainerStatusRequest): Buffer =>
      Buffer.from(GetContainerStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetContainerStatusRequest => GetContainerStatusRequest.decode(value),
    responseSerialize: (value: GetContainerStatusResponse): Buffer =>
      Buffer.from(GetContainerStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetContainerStatusResponse => GetContainerStatusResponse.decode(value),
  },
  /** Health check */
  health: {
    path: "/container_manager.ContainerManager/Health",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthRequest): Buffer => Buffer.from(HealthRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): HealthRequest => HealthRequest.decode(value),
    responseSerialize: (value: HealthResponse): Buffer => Buffer.from(HealthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): HealthResponse => HealthResponse.decode(value),
  },
  /** Get node resources (CPU, memory, disk) */
  getNodeResources: {
    path: "/container_manager.ContainerManager/GetNodeResources",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetNodeResourcesRequest): Buffer =>
      Buffer.from(GetNodeResourcesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetNodeResourcesRequest => GetNodeResourcesRequest.decode(value),
    responseSerialize: (value: GetNodeResourcesResponse): Buffer =>
      Buffer.from(GetNodeResourcesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetNodeResourcesResponse => GetNodeResourcesResponse.decode(value),
  },
  /** Get available Docker images on this node */
  getAvailableImages: {
    path: "/container_manager.ContainerManager/GetAvailableImages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAvailableImagesRequest): Buffer =>
      Buffer.from(GetAvailableImagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetAvailableImagesRequest => GetAvailableImagesRequest.decode(value),
    responseSerialize: (value: GetAvailableImagesResponse): Buffer =>
      Buffer.from(GetAvailableImagesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetAvailableImagesResponse => GetAvailableImagesResponse.decode(value),
  },
} as const;

export interface ContainerManagerServer extends UntypedServiceImplementation {
  /**
   * Unified bidirectional stream for container lifecycle
   * First message MUST be RunRequest with create field set
   * Server sends stdout/stderr/messages/exit events
   * Client can send stdin
   * Client MUST send heartbeat every 30 seconds or container will be terminated
   * Connection close/interrupt automatically terminates container
   */
  run: handleBidiStreamingCall<RunRequest, RunResponse>;
  /** List all containers (running and recent) */
  listContainers: handleUnaryCall<ListContainersRequest, ListContainersResponse>;
  /** Get status of a specific container */
  getContainerStatus: handleUnaryCall<GetContainerStatusRequest, GetContainerStatusResponse>;
  /** Health check */
  health: handleUnaryCall<HealthRequest, HealthResponse>;
  /** Get node resources (CPU, memory, disk) */
  getNodeResources: handleUnaryCall<GetNodeResourcesRequest, GetNodeResourcesResponse>;
  /** Get available Docker images on this node */
  getAvailableImages: handleUnaryCall<GetAvailableImagesRequest, GetAvailableImagesResponse>;
}

export interface ContainerManagerClient extends Client {
  /**
   * Unified bidirectional stream for container lifecycle
   * First message MUST be RunRequest with create field set
   * Server sends stdout/stderr/messages/exit events
   * Client can send stdin
   * Client MUST send heartbeat every 30 seconds or container will be terminated
   * Connection close/interrupt automatically terminates container
   */
  run(): ClientDuplexStream<RunRequest, RunResponse>;
  run(options: Partial<CallOptions>): ClientDuplexStream<RunRequest, RunResponse>;
  run(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<RunRequest, RunResponse>;
  /** List all containers (running and recent) */
  listContainers(
    request: ListContainersRequest,
    callback: (error: ServiceError | null, response: ListContainersResponse) => void,
  ): ClientUnaryCall;
  listContainers(
    request: ListContainersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListContainersResponse) => void,
  ): ClientUnaryCall;
  listContainers(
    request: ListContainersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListContainersResponse) => void,
  ): ClientUnaryCall;
  /** Get status of a specific container */
  getContainerStatus(
    request: GetContainerStatusRequest,
    callback: (error: ServiceError | null, response: GetContainerStatusResponse) => void,
  ): ClientUnaryCall;
  getContainerStatus(
    request: GetContainerStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetContainerStatusResponse) => void,
  ): ClientUnaryCall;
  getContainerStatus(
    request: GetContainerStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetContainerStatusResponse) => void,
  ): ClientUnaryCall;
  /** Health check */
  health(
    request: HealthRequest,
    callback: (error: ServiceError | null, response: HealthResponse) => void,
  ): ClientUnaryCall;
  health(
    request: HealthRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthResponse) => void,
  ): ClientUnaryCall;
  health(
    request: HealthRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthResponse) => void,
  ): ClientUnaryCall;
  /** Get node resources (CPU, memory, disk) */
  getNodeResources(
    request: GetNodeResourcesRequest,
    callback: (error: ServiceError | null, response: GetNodeResourcesResponse) => void,
  ): ClientUnaryCall;
  getNodeResources(
    request: GetNodeResourcesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetNodeResourcesResponse) => void,
  ): ClientUnaryCall;
  getNodeResources(
    request: GetNodeResourcesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetNodeResourcesResponse) => void,
  ): ClientUnaryCall;
  /** Get available Docker images on this node */
  getAvailableImages(
    request: GetAvailableImagesRequest,
    callback: (error: ServiceError | null, response: GetAvailableImagesResponse) => void,
  ): ClientUnaryCall;
  getAvailableImages(
    request: GetAvailableImagesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetAvailableImagesResponse) => void,
  ): ClientUnaryCall;
  getAvailableImages(
    request: GetAvailableImagesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetAvailableImagesResponse) => void,
  ): ClientUnaryCall;
}

export const ContainerManagerClient = makeGenericClientConstructor(
  ContainerManagerService,
  "container_manager.ContainerManager",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ContainerManagerClient;
  service: typeof ContainerManagerService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
